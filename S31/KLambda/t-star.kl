(defun shen.typecheck (V4258 V4259) (let Vs (shen.extract-vars V4259) (let A* (shen.rectify-type V4259) (let Curried (shen.curry V4258) (((((lambda V3660 (lambda L3661 (lambda K3662 (lambda C3663 (let Out (shen.newpv V3660) (shen.gc V3660 (do (shen.incinfs) (shen.insert-prolog-variables (receive (shen.deref Vs V3660)) (receive (shen.deref A* V3660)) Out V3660 L3661 K3662 (freeze (shen.toplevel-forms (receive (shen.deref Curried V3660)) Out V3660 L3661 K3662 (freeze (return Out V3660 L3661 K3662 C3663)))))))))))) (shen.reset-prolog-vector)) (@v true (@v 0 (vector 0)))) 0) (freeze true))))))

(defun shen.insert-prolog-variables (V4260 V4261 V4262 V4263 V4264 V4265 V4266) (let C3672 (if (shen.unlocked? V4264) (let Tm3673 (shen.lazyderef V4260 V4263) (if (= Tm3673 ()) (do (shen.incinfs) (is! V4261 V4262 V4263 V4264 V4265 V4266)) false)) false) (if (= C3672 false) (if (shen.unlocked? V4264) (let Tm3674 (shen.lazyderef V4260 V4263) (if (cons? Tm3674) (let V (hd Tm3674) (let Vs (tl Tm3674) (let X (shen.newpv V4263) (shen.gc V4263 (do (shen.incinfs) (shen.insert-prolog-variables Vs (subst (shen.deref X V4263) V V4261) V4262 V4263 V4264 V4265 V4266)))))) false)) false) C3672)))

(defun shen.toplevel-forms (V4267 V4268 V4269 V4270 V4271 V4272) (let K3677 (+ V4271 1) (let C3681 (if (shen.unlocked? V4270) (let Tm3682 (shen.lazyderef V4267 V4269) (if (cons? Tm3682) (let Tm3683 (shen.lazyderef (hd Tm3682) V4269) (if (= Tm3683 define) (let Tm3684 (shen.lazyderef (tl Tm3682) V4269) (if (cons? Tm3684) (let F (hd Tm3684) (let X (tl Tm3684) (do (shen.incinfs) (shen.cut V4269 V4270 K3677 (freeze (shen.signal-def (value shen.*spy*) F V4269 V4270 K3677 (freeze (shen.t* (cons define (cons F X)) V4268 V4269 V4270 K3677 V4272)))))))) false)) false)) false)) false) (if (= C3681 false) (let C3685 (if (shen.unlocked? V4270) (do (shen.incinfs) (shen.system-S (cons V4267 (cons (intern ":") (cons V4268 ()))) () V4269 V4270 K3677 V4272)) false) (if (= C3685 false) (shen.unlock V4270 K3677) C3685)) C3681))))

(defun shen.signal-def (V4273 V4274 V4275 V4276 V4277 V4278) (let C3692 (if (shen.unlocked? V4276) (let Tm3693 (shen.lazyderef V4273 V4275) (if (= Tm3693 false) (do (shen.incinfs) (thaw V4278)) false)) false) (if (= C3692 false) (if (shen.unlocked? V4276) (let Tm3694 (shen.lazyderef V4273 V4275) (if (= Tm3694 true) (let ShowF (shen.newpv V4275) (shen.gc V4275 (do (shen.incinfs) (is ShowF (pr (cn "
typechecking (fn " (shen.app (shen.deref V4274 V4275) ")
" shen.a)) (stoutput)) V4275 V4276 V4277 V4278)))) false)) false) C3692)))

(defun shen.rectify-type (V4279) (shen.demodulate (shen.curry-type V4279)))

(defun shen.demodulate (V4280) (trap-error (let Demod (shen.walk (lambda Y (shen.demod Y)) V4280) (if (= Demod V4280) V4280 (shen.demodulate Demod))) (lambda E V4280)))

(defun shen.curry-type (V4281) (cond ((and (cons? V4281) (and (cons? (tl V4281)) (and (= --> (hd (tl V4281))) (and (cons? (tl (tl V4281))) (and (cons? (tl (tl (tl V4281)))) (= --> (hd (tl (tl (tl V4281)))))))))) (shen.curry-type (cons (hd V4281) (cons --> (cons (tl (tl V4281)) ()))))) ((and (cons? V4281) (and (cons? (tl V4281)) (and (= ==> (hd (tl V4281))) (and (cons? (tl (tl V4281))) (= () (tl (tl (tl V4281)))))))) (shen.curry-type (cons (cons (hd V4281) (cons * (cons (protect A) ()))) (cons --> (cons (cons (cons vector (cons boolean ())) (cons --> (cons (cons (hd V4281) (cons * (tl (tl V4281)))) ()))) ()))))) ((and (cons? V4281) (and (cons? (tl V4281)) (and (= * (hd (tl V4281))) (and (cons? (tl (tl V4281))) (and (cons? (tl (tl (tl V4281)))) (= * (hd (tl (tl (tl V4281)))))))))) (shen.curry-type (cons (hd V4281) (cons * (cons (tl (tl V4281)) ()))))) ((cons? V4281) (map (lambda Z (shen.curry-type Z)) V4281)) (true V4281)))

(defun shen.curry (V4282) (cond ((and (cons? V4282) (and (= define (hd V4282)) (cons? (tl V4282)))) V4282) ((and (cons? V4282) (and (= type (hd V4282)) (and (cons? (tl V4282)) (and (cons? (tl (tl V4282))) (= () (tl (tl (tl V4282)))))))) (cons type (cons (shen.curry (hd (tl V4282))) (tl (tl V4282))))) ((and (cons? V4282) (and (= input+ (hd V4282)) (and (cons? (tl V4282)) (and (cons? (tl (tl V4282))) (= () (tl (tl (tl V4282)))))))) (cons input+ (cons (hd (tl V4282)) (cons (shen.curry (hd (tl (tl V4282)))) ())))) ((and (cons? V4282) (shen.special? (hd V4282))) (cons (hd V4282) (map (lambda Y (shen.curry Y)) (tl V4282)))) ((and (cons? V4282) (shen.extraspecial? (hd V4282))) V4282) ((and (cons? V4282) (and (cons? (tl V4282)) (cons? (tl (tl V4282))))) (shen.curry (cons (cons (hd V4282) (cons (hd (tl V4282)) ())) (tl (tl V4282))))) ((and (cons? V4282) (and (cons? (tl V4282)) (= () (tl (tl V4282))))) (cons (shen.curry (hd V4282)) (cons (shen.curry (hd (tl V4282))) ()))) (true V4282)))

(defun shen.special? (V4283) (element? V4283 (value shen.*special*)))

(defun shen.extraspecial? (V4284) (element? V4284 (value shen.*extraspecial*)))

(defun shen.system-S (V4285 V4286 V4287 V4288 V4289 V4290) (let K3697 (+ V4289 1) (let C3701 (if (shen.unlocked? V4288) (do (shen.incinfs) (when (shen.maxinfexceeded?) V4287 V4288 K3697 V4290)) false) (if (= C3701 false) (let C3702 (if (shen.unlocked? V4288) (let Tm3703 (shen.lazyderef V4285 V4287) (if (cons? Tm3703) (let X (hd Tm3703) (let Tm3704 (shen.lazyderef (tl Tm3703) V4287) (if (cons? Tm3704) (let Colon (hd Tm3704) (let Tm3705 (shen.lazyderef (tl Tm3704) V4287) (if (cons? Tm3705) (let A (hd Tm3705) (let Tm3706 (shen.lazyderef (tl Tm3705) V4287) (if (= Tm3706 ()) (do (shen.incinfs) (when (= (shen.deref Colon V4287) (intern ":")) V4287 V4288 K3697 (freeze (when (shen.type-theory-enabled?) V4287 V4288 K3697 (freeze (shen.cut V4287 V4288 K3697 (freeze (shen.system-S-h X A V4286 V4287 V4288 K3697 V4290)))))))) false))) false))) false))) false)) false) (if (= C3702 false) (let C3707 (if (shen.unlocked? V4288) (do (shen.incinfs) (when (value shen.*spy*) V4287 V4288 K3697 (freeze (shen.show V4285 V4286 V4287 V4288 K3697 V4290)))) false) (if (= C3707 false) (let C3708 (if (shen.unlocked? V4288) (do (shen.incinfs) (shen.search-user-datatypes V4285 V4286 (value shen.*datatypes*) V4287 V4288 K3697 V4290)) false) (if (= C3708 false) (shen.unlock V4288 K3697) C3708)) C3707)) C3702)) C3701))))

(defun shen.show (V4297 V4298 V4299 V4300 V4301 V4302) (do (shen.line) (do (shen.show-p (shen.deref V4297 V4299)) (do (nl 2) (do (shen.show-assumptions (shen.deref V4298 V4299) 1) (do (shen.pause-for-user) false))))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V4303) (cond ((and (cons? V4303) (and (cons? (tl V4303)) (and (cons? (tl (tl V4303))) (and (= () (tl (tl (tl V4303)))) (= (hd (tl V4303)) (intern ":")))))) (do (shen.prterm (hd V4303)) (do (pr " : " (stoutput)) (pr (shen.app (hd (tl (tl V4303))) "" shen.r) (stoutput))))) (true (shen.prterm V4303))))

(defun shen.prterm (V4304) (cond ((and (cons? V4304) (and (= cons (hd V4304)) (and (cons? (tl V4304)) (and (cons? (tl (tl V4304))) (= () (tl (tl (tl V4304)))))))) (do (pr "[" (stoutput)) (do (shen.prterm (hd (tl V4304))) (do (shen.prtl (hd (tl (tl V4304)))) (pr "]" (stoutput)))))) ((cons? V4304) (do (pr "(" (stoutput)) (do (shen.prterm (hd V4304)) (do (map (lambda Y (do (pr " " (stoutput)) (shen.prterm Y))) (tl V4304)) (pr ")" (stoutput)))))) (true (print V4304))))

(defun shen.prtl (V4305) (cond ((= () V4305) "") ((and (cons? V4305) (and (= cons (hd V4305)) (and (cons? (tl V4305)) (and (cons? (tl (tl V4305))) (= () (tl (tl (tl V4305)))))))) (do (pr " " (stoutput)) (do (shen.prterm (hd (tl V4305))) (shen.prtl (hd (tl (tl V4305))))))) (true (do (pr " | " (stoutput)) (shen.prterm V4305)))))

(defun shen.show-assumptions (V4312 V4313) (cond ((= () V4312) (pr "
> " (stoutput))) ((cons? V4312) (do (pr (shen.app V4313 ". " shen.a) (stoutput)) (do (shen.show-p (hd V4312)) (do (nl 1) (shen.show-assumptions (tl V4312) (+ V4313 1)))))) (true (simple-error "implementation error in shen.show-assumptions"))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun shen.maxinfexceeded? () (if (> (inferences) (value shen.*maxinferences*)) (simple-error "maximum inferences exceeded") false))

(defun shen.system-S-h (V4314 V4315 V4316 V4317 V4318 V4319 V4320) (let K3712 (+ V4319 1) (let C3717 (if (shen.unlocked? V4318) (do (shen.incinfs) (when (value shen.*spy*) V4317 V4318 K3712 (freeze (shen.show (cons V4314 (cons (intern ":") (cons V4315 ()))) V4316 V4317 V4318 K3712 V4320)))) false) (if (= C3717 false) (let C3718 (if (shen.unlocked? V4318) (do (shen.incinfs) (when (not (cons? (shen.lazyderef V4314 V4317))) V4317 V4318 K3712 (freeze (shen.primitive V4314 V4315 V4317 V4318 K3712 V4320)))) false) (if (= C3718 false) (let C3719 (if (shen.unlocked? V4318) (do (shen.incinfs) (shen.by-hypothesis V4314 V4315 V4316 V4317 V4318 K3712 V4320)) false) (if (= C3719 false) (let C3720 (if (shen.unlocked? V4318) (let Tm3721 (shen.lazyderef V4314 V4317) (if (cons? Tm3721) (let F (hd Tm3721) (let Tm3722 (shen.lazyderef (tl Tm3721) V4317) (if (= Tm3722 ()) (do (shen.incinfs) (shen.lookupsig F (cons --> (cons V4315 ())) V4317 V4318 K3712 V4320)) false))) false)) false) (if (= C3720 false) (let C3723 (if (shen.unlocked? V4318) (let Tm3724 (shen.lazyderef V4314 V4317) (if (cons? Tm3724) (let Tm3725 (shen.lazyderef (hd Tm3724) V4317) (if (= Tm3725 fn) (let Tm3726 (shen.lazyderef (tl Tm3724) V4317) (if (cons? Tm3726) (let F (hd Tm3726) (let Tm3727 (shen.lazyderef (tl Tm3726) V4317) (if (= Tm3727 ()) (do (shen.incinfs) (shen.lookupsig F V4315 V4317 V4318 K3712 V4320)) false))) false)) false)) false)) false) (if (= C3723 false) (let C3728 (if (shen.unlocked? V4318) (let Tm3729 (shen.lazyderef V4314 V4317) (if (cons? Tm3729) (let F (hd Tm3729) (let Tm3730 (shen.lazyderef (tl Tm3729) V4317) (if (cons? Tm3730) (let X (hd Tm3730) (let Tm3731 (shen.lazyderef (tl Tm3730) V4317) (if (= Tm3731 ()) (let B (shen.newpv V4317) (shen.gc V4317 (do (shen.incinfs) (when (not (cons? (shen.lazyderef F V4317))) V4317 V4318 K3712 (freeze (shen.lookupsig F (cons B (cons --> (cons V4315 ()))) V4317 V4318 K3712 (freeze (shen.system-S-h X B V4316 V4317 V4318 K3712 V4320)))))))) false))) false))) false)) false) (if (= C3728 false) (let C3732 (if (shen.unlocked? V4318) (let Tm3733 (shen.lazyderef V4314 V4317) (if (cons? Tm3733) (let F (hd Tm3733) (let Tm3734 (shen.lazyderef (tl Tm3733) V4317) (if (cons? Tm3734) (let X (hd Tm3734) (let Tm3735 (shen.lazyderef (tl Tm3734) V4317) (if (= Tm3735 ()) (let B (shen.newpv V4317) (shen.gc V4317 (do (shen.incinfs) (shen.system-S-h F (cons B (cons --> (cons V4315 ()))) V4316 V4317 V4318 K3712 (freeze (shen.system-S-h X B V4316 V4317 V4318 K3712 V4320)))))) false))) false))) false)) false) (if (= C3732 false) (let C3736 (if (shen.unlocked? V4318) (let Tm3737 (shen.lazyderef V4314 V4317) (if (cons? Tm3737) (let Tm3738 (shen.lazyderef (hd Tm3737) V4317) (if (= Tm3738 cons) (let Tm3739 (shen.lazyderef (tl Tm3737) V4317) (if (cons? Tm3739) (let X (hd Tm3739) (let Tm3740 (shen.lazyderef (tl Tm3739) V4317) (if (cons? Tm3740) (let Y (hd Tm3740) (let Tm3741 (shen.lazyderef (tl Tm3740) V4317) (if (= Tm3741 ()) (let Tm3742 (shen.lazyderef V4315 V4317) (let GoTo3743 (lambda A (do (shen.incinfs) (shen.system-S-h X A V4316 V4317 V4318 K3712 (freeze (shen.system-S-h Y (cons list (cons A ())) V4316 V4317 V4318 K3712 V4320))))) (if (cons? Tm3742) (let Tm3744 (shen.lazyderef (hd Tm3742) V4317) (let GoTo3745 (freeze (let Tm3746 (shen.lazyderef (tl Tm3742) V4317) (let GoTo3747 (lambda A (GoTo3743 A)) (if (cons? Tm3746) (let A (hd Tm3746) (let Tm3748 (shen.lazyderef (tl Tm3746) V4317) (let GoTo3749 (freeze (GoTo3747 A)) (if (= Tm3748 ()) (thaw GoTo3749) (if (shen.pvar? Tm3748) (shen.bind! Tm3748 () V4317 GoTo3749) false))))) (if (shen.pvar? Tm3746) (let A (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3746 (cons A ()) V4317 (freeze (GoTo3747 A))))) false))))) (if (= Tm3744 list) (thaw GoTo3745) (if (shen.pvar? Tm3744) (shen.bind! Tm3744 list V4317 GoTo3745) false)))) (if (shen.pvar? Tm3742) (let A (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3742 (cons list (cons A ())) V4317 (freeze (GoTo3743 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3736 false) (let C3750 (if (shen.unlocked? V4318) (let Tm3751 (shen.lazyderef V4314 V4317) (if (cons? Tm3751) (let Tm3752 (shen.lazyderef (hd Tm3751) V4317) (if (= Tm3752 @p) (let Tm3753 (shen.lazyderef (tl Tm3751) V4317) (if (cons? Tm3753) (let X (hd Tm3753) (let Tm3754 (shen.lazyderef (tl Tm3753) V4317) (if (cons? Tm3754) (let Y (hd Tm3754) (let Tm3755 (shen.lazyderef (tl Tm3754) V4317) (if (= Tm3755 ()) (let Tm3756 (shen.lazyderef V4315 V4317) (let GoTo3757 (lambda A (lambda B (do (shen.incinfs) (shen.system-S-h X A V4316 V4317 V4318 K3712 (freeze (shen.system-S-h Y B V4316 V4317 V4318 K3712 V4320)))))) (if (cons? Tm3756) (let A (hd Tm3756) (let Tm3758 (shen.lazyderef (tl Tm3756) V4317) (let GoTo3759 (lambda B ((GoTo3757 A) B)) (if (cons? Tm3758) (let Tm3760 (shen.lazyderef (hd Tm3758) V4317) (let GoTo3761 (freeze (let Tm3762 (shen.lazyderef (tl Tm3758) V4317) (let GoTo3763 (lambda B (GoTo3759 B)) (if (cons? Tm3762) (let B (hd Tm3762) (let Tm3764 (shen.lazyderef (tl Tm3762) V4317) (let GoTo3765 (freeze (GoTo3763 B)) (if (= Tm3764 ()) (thaw GoTo3765) (if (shen.pvar? Tm3764) (shen.bind! Tm3764 () V4317 GoTo3765) false))))) (if (shen.pvar? Tm3762) (let B (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3762 (cons B ()) V4317 (freeze (GoTo3763 B))))) false))))) (if (= Tm3760 *) (thaw GoTo3761) (if (shen.pvar? Tm3760) (shen.bind! Tm3760 * V4317 GoTo3761) false)))) (if (shen.pvar? Tm3758) (let B (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3758 (cons * (cons B ())) V4317 (freeze (GoTo3759 B))))) false))))) (if (shen.pvar? Tm3756) (let A (shen.newpv V4317) (shen.gc V4317 (let B (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3756 (cons A (cons * (cons B ()))) V4317 (freeze ((GoTo3757 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3750 false) (let C3766 (if (shen.unlocked? V4318) (let Tm3767 (shen.lazyderef V4314 V4317) (if (cons? Tm3767) (let Tm3768 (shen.lazyderef (hd Tm3767) V4317) (if (= Tm3768 @v) (let Tm3769 (shen.lazyderef (tl Tm3767) V4317) (if (cons? Tm3769) (let X (hd Tm3769) (let Tm3770 (shen.lazyderef (tl Tm3769) V4317) (if (cons? Tm3770) (let Y (hd Tm3770) (let Tm3771 (shen.lazyderef (tl Tm3770) V4317) (if (= Tm3771 ()) (let Tm3772 (shen.lazyderef V4315 V4317) (let GoTo3773 (lambda A (do (shen.incinfs) (shen.system-S-h X A V4316 V4317 V4318 K3712 (freeze (shen.system-S-h Y (cons vector (cons A ())) V4316 V4317 V4318 K3712 V4320))))) (if (cons? Tm3772) (let Tm3774 (shen.lazyderef (hd Tm3772) V4317) (let GoTo3775 (freeze (let Tm3776 (shen.lazyderef (tl Tm3772) V4317) (let GoTo3777 (lambda A (GoTo3773 A)) (if (cons? Tm3776) (let A (hd Tm3776) (let Tm3778 (shen.lazyderef (tl Tm3776) V4317) (let GoTo3779 (freeze (GoTo3777 A)) (if (= Tm3778 ()) (thaw GoTo3779) (if (shen.pvar? Tm3778) (shen.bind! Tm3778 () V4317 GoTo3779) false))))) (if (shen.pvar? Tm3776) (let A (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3776 (cons A ()) V4317 (freeze (GoTo3777 A))))) false))))) (if (= Tm3774 vector) (thaw GoTo3775) (if (shen.pvar? Tm3774) (shen.bind! Tm3774 vector V4317 GoTo3775) false)))) (if (shen.pvar? Tm3772) (let A (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3772 (cons vector (cons A ())) V4317 (freeze (GoTo3773 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3766 false) (let C3780 (if (shen.unlocked? V4318) (let Tm3781 (shen.lazyderef V4314 V4317) (if (cons? Tm3781) (let Tm3782 (shen.lazyderef (hd Tm3781) V4317) (if (= Tm3782 @s) (let Tm3783 (shen.lazyderef (tl Tm3781) V4317) (if (cons? Tm3783) (let X (hd Tm3783) (let Tm3784 (shen.lazyderef (tl Tm3783) V4317) (if (cons? Tm3784) (let Y (hd Tm3784) (let Tm3785 (shen.lazyderef (tl Tm3784) V4317) (if (= Tm3785 ()) (let Tm3786 (shen.lazyderef V4315 V4317) (let GoTo3787 (freeze (do (shen.incinfs) (shen.system-S-h X string V4316 V4317 V4318 K3712 (freeze (shen.system-S-h Y string V4316 V4317 V4318 K3712 V4320))))) (if (= Tm3786 string) (thaw GoTo3787) (if (shen.pvar? Tm3786) (shen.bind! Tm3786 string V4317 GoTo3787) false)))) false))) false))) false)) false)) false)) false) (if (= C3780 false) (let C3788 (if (shen.unlocked? V4318) (let Tm3789 (shen.lazyderef V4314 V4317) (if (cons? Tm3789) (let Tm3790 (shen.lazyderef (hd Tm3789) V4317) (if (= Tm3790 lambda) (let Tm3791 (shen.lazyderef (tl Tm3789) V4317) (if (cons? Tm3791) (let X (hd Tm3791) (let Tm3792 (shen.lazyderef (tl Tm3791) V4317) (if (cons? Tm3792) (let Y (hd Tm3792) (let Tm3793 (shen.lazyderef (tl Tm3792) V4317) (if (= Tm3793 ()) (let Tm3794 (shen.lazyderef V4315 V4317) (let GoTo3795 (lambda A (lambda B (let Z (shen.newpv V4317) (shen.gc V4317 (let New (shen.newpv V4317) (shen.gc V4317 (do (shen.incinfs) (bind New (shen.freshterm (shen.lazyderef X V4317)) V4317 V4318 K3712 (freeze (bind Z (shen.beta (shen.lazyderef X V4317) (shen.deref New V4317) (shen.deref Y V4317)) V4317 V4318 K3712 (freeze (shen.system-S-h Z B (cons (cons New (cons (intern ":") (cons A ()))) V4316) V4317 V4318 K3712 V4320)))))))))))) (if (cons? Tm3794) (let A (hd Tm3794) (let Tm3796 (shen.lazyderef (tl Tm3794) V4317) (let GoTo3797 (lambda B ((GoTo3795 A) B)) (if (cons? Tm3796) (let Tm3798 (shen.lazyderef (hd Tm3796) V4317) (let GoTo3799 (freeze (let Tm3800 (shen.lazyderef (tl Tm3796) V4317) (let GoTo3801 (lambda B (GoTo3797 B)) (if (cons? Tm3800) (let B (hd Tm3800) (let Tm3802 (shen.lazyderef (tl Tm3800) V4317) (let GoTo3803 (freeze (GoTo3801 B)) (if (= Tm3802 ()) (thaw GoTo3803) (if (shen.pvar? Tm3802) (shen.bind! Tm3802 () V4317 GoTo3803) false))))) (if (shen.pvar? Tm3800) (let B (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3800 (cons B ()) V4317 (freeze (GoTo3801 B))))) false))))) (if (= Tm3798 -->) (thaw GoTo3799) (if (shen.pvar? Tm3798) (shen.bind! Tm3798 --> V4317 GoTo3799) false)))) (if (shen.pvar? Tm3796) (let B (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3796 (cons --> (cons B ())) V4317 (freeze (GoTo3797 B))))) false))))) (if (shen.pvar? Tm3794) (let A (shen.newpv V4317) (shen.gc V4317 (let B (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3794 (cons A (cons --> (cons B ()))) V4317 (freeze ((GoTo3795 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3788 false) (let C3804 (if (shen.unlocked? V4318) (let Tm3805 (shen.lazyderef V4314 V4317) (if (cons? Tm3805) (let Tm3806 (shen.lazyderef (hd Tm3805) V4317) (if (= Tm3806 let) (let Tm3807 (shen.lazyderef (tl Tm3805) V4317) (if (cons? Tm3807) (let X (hd Tm3807) (let Tm3808 (shen.lazyderef (tl Tm3807) V4317) (if (cons? Tm3808) (let Y (hd Tm3808) (let Tm3809 (shen.lazyderef (tl Tm3808) V4317) (if (cons? Tm3809) (let Z (hd Tm3809) (let Tm3810 (shen.lazyderef (tl Tm3809) V4317) (if (= Tm3810 ()) (let W (shen.newpv V4317) (shen.gc V4317 (let New (shen.newpv V4317) (shen.gc V4317 (let B (shen.newpv V4317) (shen.gc V4317 (do (shen.incinfs) (shen.system-S-h Y B V4316 V4317 V4318 K3712 (freeze (bind New (shen.freshterm (shen.lazyderef X V4317)) V4317 V4318 K3712 (freeze (bind W (shen.beta (shen.lazyderef X V4317) (shen.lazyderef New V4317) (shen.lazyderef Z V4317)) V4317 V4318 K3712 (freeze (shen.system-S-h W V4315 (cons (cons New (cons (intern ":") (cons B ()))) V4316) V4317 V4318 K3712 V4320)))))))))))))) false))) false))) false))) false)) false)) false)) false) (if (= C3804 false) (let C3811 (if (shen.unlocked? V4318) (let Tm3812 (shen.lazyderef V4314 V4317) (if (cons? Tm3812) (let Tm3813 (shen.lazyderef (hd Tm3812) V4317) (if (= Tm3813 open) (let Tm3814 (shen.lazyderef (tl Tm3812) V4317) (if (cons? Tm3814) (let File (hd Tm3814) (let Tm3815 (shen.lazyderef (tl Tm3814) V4317) (if (cons? Tm3815) (let V3709 (hd Tm3815) (let Tm3816 (shen.lazyderef (tl Tm3815) V4317) (if (= Tm3816 ()) (let Tm3817 (shen.lazyderef V4315 V4317) (let GoTo3818 (lambda D (do (shen.incinfs) (is! V3709 D V4317 V4318 K3712 (freeze (when (element? (shen.lazyderef D V4317) (cons in (cons out ()))) V4317 V4318 K3712 (freeze (shen.system-S-h File string V4316 V4317 V4318 K3712 V4320))))))) (if (cons? Tm3817) (let Tm3819 (shen.lazyderef (hd Tm3817) V4317) (let GoTo3820 (freeze (let Tm3821 (shen.lazyderef (tl Tm3817) V4317) (let GoTo3822 (lambda D (GoTo3818 D)) (if (cons? Tm3821) (let D (hd Tm3821) (let Tm3823 (shen.lazyderef (tl Tm3821) V4317) (let GoTo3824 (freeze (GoTo3822 D)) (if (= Tm3823 ()) (thaw GoTo3824) (if (shen.pvar? Tm3823) (shen.bind! Tm3823 () V4317 GoTo3824) false))))) (if (shen.pvar? Tm3821) (let D (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3821 (cons D ()) V4317 (freeze (GoTo3822 D))))) false))))) (if (= Tm3819 stream) (thaw GoTo3820) (if (shen.pvar? Tm3819) (shen.bind! Tm3819 stream V4317 GoTo3820) false)))) (if (shen.pvar? Tm3817) (let D (shen.newpv V4317) (shen.gc V4317 (shen.bind! Tm3817 (cons stream (cons D ())) V4317 (freeze (GoTo3818 D))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3811 false) (let C3825 (if (shen.unlocked? V4318) (let Tm3826 (shen.lazyderef V4314 V4317) (if (cons? Tm3826) (let Tm3827 (shen.lazyderef (hd Tm3826) V4317) (if (= Tm3827 type) (let Tm3828 (shen.lazyderef (tl Tm3826) V4317) (if (cons? Tm3828) (let X (hd Tm3828) (let Tm3829 (shen.lazyderef (tl Tm3828) V4317) (if (cons? Tm3829) (let A (hd Tm3829) (let Tm3830 (shen.lazyderef (tl Tm3829) V4317) (if (= Tm3830 ()) (do (shen.incinfs) (shen.cut V4317 V4318 K3712 (freeze (is! (shen.rectify-type (shen.deref A V4317)) V4315 V4317 V4318 K3712 (freeze (shen.system-S-h X V4315 V4316 V4317 V4318 K3712 V4320)))))) false))) false))) false)) false)) false)) false) (if (= C3825 false) (let C3831 (if (shen.unlocked? V4318) (let Tm3832 (shen.lazyderef V4314 V4317) (if (cons? Tm3832) (let Tm3833 (shen.lazyderef (hd Tm3832) V4317) (if (= Tm3833 input+) (let Tm3834 (shen.lazyderef (tl Tm3832) V4317) (if (cons? Tm3834) (let A (hd Tm3834) (let Tm3835 (shen.lazyderef (tl Tm3834) V4317) (if (cons? Tm3835) (let Stream (hd Tm3835) (let Tm3836 (shen.lazyderef (tl Tm3835) V4317) (if (= Tm3836 ()) (do (shen.incinfs) (is! V4315 (shen.rectify-type (shen.deref A V4317)) V4317 V4318 K3712 (freeze (shen.system-S-h Stream (cons stream (cons in ())) V4316 V4317 V4318 K3712 V4320)))) false))) false))) false)) false)) false)) false) (if (= C3831 false) (let C3837 (if (shen.unlocked? V4318) (let Tm3838 (shen.lazyderef V4314 V4317) (if (cons? Tm3838) (let Tm3839 (shen.lazyderef (hd Tm3838) V4317) (if (= Tm3839 set) (let Tm3840 (shen.lazyderef (tl Tm3838) V4317) (if (cons? Tm3840) (let Var (hd Tm3840) (let Tm3841 (shen.lazyderef (tl Tm3840) V4317) (if (cons? Tm3841) (let Val (hd Tm3841) (let Tm3842 (shen.lazyderef (tl Tm3841) V4317) (if (= Tm3842 ()) (do (shen.incinfs) (shen.system-S-h Var symbol V4316 V4317 V4318 K3712 (freeze (shen.system-S-h (cons value (cons Var ())) V4315 V4316 V4317 V4318 K3712 (freeze (shen.system-S-h Val V4315 V4316 V4317 V4318 K3712 V4320)))))) false))) false))) false)) false)) false)) false) (if (= C3837 false) (let C3843 (if (shen.unlocked? V4318) (let Normalised (shen.newpv V4317) (shen.gc V4317 (do (shen.incinfs) (shen.l-rules V4316 Normalised false V4317 V4318 K3712 (freeze (shen.cut V4317 V4318 K3712 (freeze (shen.system-S-h V4314 V4315 Normalised V4317 V4318 K3712 V4320)))))))) false) (if (= C3843 false) (let C3844 (if (shen.unlocked? V4318) (do (shen.incinfs) (shen.search-user-datatypes (cons V4314 (cons (intern ":") (cons V4315 ()))) V4316 (value shen.*datatypes*) V4317 V4318 K3712 V4320)) false) (if (= C3844 false) (shen.unlock V4318 K3712) C3844)) C3843)) C3837)) C3831)) C3825)) C3811)) C3804)) C3788)) C3780)) C3766)) C3750)) C3736)) C3732)) C3728)) C3723)) C3720)) C3719)) C3718)) C3717))))

(defun shen.primitive (V4321 V4322 V4323 V4324 V4325 V4326) (let C3851 (if (shen.unlocked? V4324) (let Tm3852 (shen.lazyderef V4322 V4323) (let GoTo3853 (freeze (do (shen.incinfs) (when (number? (shen.lazyderef V4321 V4323)) V4323 V4324 V4325 V4326))) (if (= Tm3852 number) (thaw GoTo3853) (if (shen.pvar? Tm3852) (shen.bind! Tm3852 number V4323 GoTo3853) false)))) false) (if (= C3851 false) (let C3854 (if (shen.unlocked? V4324) (let Tm3855 (shen.lazyderef V4322 V4323) (let GoTo3856 (freeze (do (shen.incinfs) (when (boolean? (shen.lazyderef V4321 V4323)) V4323 V4324 V4325 V4326))) (if (= Tm3855 boolean) (thaw GoTo3856) (if (shen.pvar? Tm3855) (shen.bind! Tm3855 boolean V4323 GoTo3856) false)))) false) (if (= C3854 false) (let C3857 (if (shen.unlocked? V4324) (let Tm3858 (shen.lazyderef V4322 V4323) (let GoTo3859 (freeze (do (shen.incinfs) (when (string? (shen.lazyderef V4321 V4323)) V4323 V4324 V4325 V4326))) (if (= Tm3858 string) (thaw GoTo3859) (if (shen.pvar? Tm3858) (shen.bind! Tm3858 string V4323 GoTo3859) false)))) false) (if (= C3857 false) (let C3860 (if (shen.unlocked? V4324) (let Tm3861 (shen.lazyderef V4322 V4323) (let GoTo3862 (freeze (do (shen.incinfs) (when (symbol? (shen.lazyderef V4321 V4323)) V4323 V4324 V4325 V4326))) (if (= Tm3861 symbol) (thaw GoTo3862) (if (shen.pvar? Tm3861) (shen.bind! Tm3861 symbol V4323 GoTo3862) false)))) false) (if (= C3860 false) (if (shen.unlocked? V4324) (let Tm3863 (shen.lazyderef V4321 V4323) (if (= Tm3863 ()) (let Tm3864 (shen.lazyderef V4322 V4323) (let GoTo3865 (lambda A (do (shen.incinfs) (thaw V4326))) (if (cons? Tm3864) (let Tm3866 (shen.lazyderef (hd Tm3864) V4323) (let GoTo3867 (freeze (let Tm3868 (shen.lazyderef (tl Tm3864) V4323) (let GoTo3869 (lambda A (GoTo3865 A)) (if (cons? Tm3868) (let A (hd Tm3868) (let Tm3870 (shen.lazyderef (tl Tm3868) V4323) (let GoTo3871 (freeze (GoTo3869 A)) (if (= Tm3870 ()) (thaw GoTo3871) (if (shen.pvar? Tm3870) (shen.bind! Tm3870 () V4323 GoTo3871) false))))) (if (shen.pvar? Tm3868) (let A (shen.newpv V4323) (shen.gc V4323 (shen.bind! Tm3868 (cons A ()) V4323 (freeze (GoTo3869 A))))) false))))) (if (= Tm3866 list) (thaw GoTo3867) (if (shen.pvar? Tm3866) (shen.bind! Tm3866 list V4323 GoTo3867) false)))) (if (shen.pvar? Tm3864) (let A (shen.newpv V4323) (shen.gc V4323 (shen.bind! Tm3864 (cons list (cons A ())) V4323 (freeze (GoTo3865 A))))) false)))) false)) false) C3860)) C3857)) C3854)) C3851)))

(defun shen.by-hypothesis (V4327 V4328 V4329 V4330 V4331 V4332 V4333) (let C3879 (if (shen.unlocked? V4331) (let Tm3880 (shen.lazyderef V4329 V4330) (if (cons? Tm3880) (let Tm3881 (shen.lazyderef (hd Tm3880) V4330) (if (cons? Tm3881) (let Y (hd Tm3881) (let Tm3882 (shen.lazyderef (tl Tm3881) V4330) (if (cons? Tm3882) (let Colon (hd Tm3882) (let Tm3883 (shen.lazyderef (tl Tm3882) V4330) (if (cons? Tm3883) (let B (hd Tm3883) (let Tm3884 (shen.lazyderef (tl Tm3883) V4330) (if (= Tm3884 ()) (do (shen.incinfs) (when (= (shen.deref Colon V4330) (intern ":")) V4330 V4331 V4332 (freeze (when (= (shen.deref V4327 V4330) (shen.deref Y V4330)) V4330 V4331 V4332 (freeze (is! V4328 B V4330 V4331 V4332 V4333)))))) false))) false))) false))) false)) false)) false) (if (= C3879 false) (if (shen.unlocked? V4331) (let Tm3885 (shen.lazyderef V4329 V4330) (if (cons? Tm3885) (let Hyp (tl Tm3885) (do (shen.incinfs) (shen.by-hypothesis V4327 V4328 Hyp V4330 V4331 V4332 V4333))) false)) false) C3879)))

(defun shen.lookupsig (V4334 V4335 V4336 V4337 V4338 V4339) (if (shen.unlocked? V4337) (do (shen.incinfs) (shen.sigf (assoc V4334 (value shen.*sigf*)) V4335 V4336 V4337 V4338 V4339)) false))

(defun shen.sigf (V4354 V4355 V4356 V4357 V4358 V4359) (cond ((cons? V4354) ((((((tl V4354) V4355) V4356) V4357) V4358) V4359)) (true false)))

(defun shen.freshterm (V4360) (let V (absvector 3) (let V0 (address-> V 0 shen.print-freshterm) (let V1 (address-> V0 1 V4360) (let V2 (address-> V1 2 (set shen.*gensym* (+ 1 (value shen.*gensym*)))) V2)))))

(defun shen.print-freshterm (V4361) (cn "&&" (str (<-address V4361 1))))

(defun shen.search-user-datatypes (V4362 V4363 V4364 V4365 V4366 V4367 V4368) (let C3899 (if (shen.unlocked? V4366) (let Tm3900 (shen.lazyderef V4364 V4365) (if (cons? Tm3900) (let Tm3901 (shen.lazyderef (hd Tm3900) V4365) (if (cons? Tm3901) (let Fn (tl Tm3901) (do (shen.incinfs) (call (((shen.deref Fn V4365) (shen.deref V4362 V4365)) (shen.deref V4363 V4365)) V4365 V4366 V4367 V4368))) false)) false)) false) (if (= C3899 false) (if (shen.unlocked? V4366) (let Tm3902 (shen.lazyderef V4364 V4365) (if (cons? Tm3902) (let Ds (tl Tm3902) (do (shen.incinfs) (shen.search-user-datatypes V4362 V4363 Ds V4365 V4366 V4367 V4368))) false)) false) C3899)))

(defun shen.l-rules (V4369 V4370 V4371 V4372 V4373 V4374 V4375) (let K3905 (+ V4374 1) (let C3910 (if (shen.unlocked? V4373) (let Tm3911 (shen.lazyderef V4369 V4372) (if (= Tm3911 ()) (let Tm3912 (shen.lazyderef V4371 V4372) (if (= Tm3912 true) (do (shen.incinfs) (shen.cut V4372 V4373 K3905 (freeze (bind V4370 () V4372 V4373 K3905 V4375)))) false)) false)) false) (if (= C3910 false) (let C3913 (if (shen.unlocked? V4373) (let Tm3914 (shen.lazyderef V4369 V4372) (if (cons? Tm3914) (let Tm3915 (shen.lazyderef (hd Tm3914) V4372) (if (cons? Tm3915) (let Tm3916 (shen.lazyderef (hd Tm3915) V4372) (if (cons? Tm3916) (let Tm3917 (shen.lazyderef (hd Tm3916) V4372) (if (= Tm3917 cons) (let Tm3918 (shen.lazyderef (tl Tm3916) V4372) (if (cons? Tm3918) (let X (hd Tm3918) (let Tm3919 (shen.lazyderef (tl Tm3918) V4372) (if (cons? Tm3919) (let Y (hd Tm3919) (let Tm3920 (shen.lazyderef (tl Tm3919) V4372) (if (= Tm3920 ()) (let Tm3921 (shen.lazyderef (tl Tm3915) V4372) (if (cons? Tm3921) (let Colon (hd Tm3921) (let Tm3922 (shen.lazyderef (tl Tm3921) V4372) (if (cons? Tm3922) (let Tm3923 (shen.lazyderef (hd Tm3922) V4372) (if (cons? Tm3923) (let Tm3924 (shen.lazyderef (hd Tm3923) V4372) (if (= Tm3924 list) (let Tm3925 (shen.lazyderef (tl Tm3923) V4372) (if (cons? Tm3925) (let A (hd Tm3925) (let Tm3926 (shen.lazyderef (tl Tm3925) V4372) (if (= Tm3926 ()) (let Tm3927 (shen.lazyderef (tl Tm3922) V4372) (if (= Tm3927 ()) (let Hyp (tl Tm3914) (do (shen.incinfs) (when (= (shen.deref Colon V4372) (intern ":")) V4372 V4373 K3905 (freeze (shen.cut V4372 V4373 K3905 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons list (cons A ())) ()))) Hyp)) V4370 true V4372 V4373 K3905 V4375))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3913 false) (let C3928 (if (shen.unlocked? V4373) (let Tm3929 (shen.lazyderef V4369 V4372) (if (cons? Tm3929) (let Tm3930 (shen.lazyderef (hd Tm3929) V4372) (if (cons? Tm3930) (let Tm3931 (shen.lazyderef (hd Tm3930) V4372) (if (cons? Tm3931) (let Tm3932 (shen.lazyderef (hd Tm3931) V4372) (if (= Tm3932 @p) (let Tm3933 (shen.lazyderef (tl Tm3931) V4372) (if (cons? Tm3933) (let X (hd Tm3933) (let Tm3934 (shen.lazyderef (tl Tm3933) V4372) (if (cons? Tm3934) (let Y (hd Tm3934) (let Tm3935 (shen.lazyderef (tl Tm3934) V4372) (if (= Tm3935 ()) (let Tm3936 (shen.lazyderef (tl Tm3930) V4372) (if (cons? Tm3936) (let Colon (hd Tm3936) (let Tm3937 (shen.lazyderef (tl Tm3936) V4372) (if (cons? Tm3937) (let Tm3938 (shen.lazyderef (hd Tm3937) V4372) (if (cons? Tm3938) (let A (hd Tm3938) (let Tm3939 (shen.lazyderef (tl Tm3938) V4372) (if (cons? Tm3939) (let Tm3940 (shen.lazyderef (hd Tm3939) V4372) (if (= Tm3940 *) (let Tm3941 (shen.lazyderef (tl Tm3939) V4372) (if (cons? Tm3941) (let B (hd Tm3941) (let Tm3942 (shen.lazyderef (tl Tm3941) V4372) (if (= Tm3942 ()) (let Tm3943 (shen.lazyderef (tl Tm3937) V4372) (if (= Tm3943 ()) (let Hyp (tl Tm3929) (do (shen.incinfs) (when (= (shen.deref Colon V4372) (intern ":")) V4372 V4373 K3905 (freeze (shen.cut V4372 V4373 K3905 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons B ()))) Hyp)) V4370 true V4372 V4373 K3905 V4375))))))) false)) false))) false)) false)) false))) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3928 false) (let C3944 (if (shen.unlocked? V4373) (let Tm3945 (shen.lazyderef V4369 V4372) (if (cons? Tm3945) (let Tm3946 (shen.lazyderef (hd Tm3945) V4372) (if (cons? Tm3946) (let Tm3947 (shen.lazyderef (hd Tm3946) V4372) (if (cons? Tm3947) (let Tm3948 (shen.lazyderef (hd Tm3947) V4372) (if (= Tm3948 @s) (let Tm3949 (shen.lazyderef (tl Tm3947) V4372) (if (cons? Tm3949) (let X (hd Tm3949) (let Tm3950 (shen.lazyderef (tl Tm3949) V4372) (if (cons? Tm3950) (let Y (hd Tm3950) (let Tm3951 (shen.lazyderef (tl Tm3950) V4372) (if (= Tm3951 ()) (let Tm3952 (shen.lazyderef (tl Tm3946) V4372) (if (cons? Tm3952) (let Colon (hd Tm3952) (let Tm3953 (shen.lazyderef (tl Tm3952) V4372) (if (cons? Tm3953) (let Tm3954 (shen.lazyderef (hd Tm3953) V4372) (if (= Tm3954 string) (let Tm3955 (shen.lazyderef (tl Tm3953) V4372) (if (= Tm3955 ()) (let Hyp (tl Tm3945) (do (shen.incinfs) (when (= (shen.deref Colon V4372) (intern ":")) V4372 V4373 K3905 (freeze (shen.cut V4372 V4373 K3905 (freeze (shen.l-rules (cons (cons X (cons Colon (cons string ()))) (cons (cons Y (cons Colon (cons string ()))) Hyp)) V4370 true V4372 V4373 K3905 V4375))))))) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3944 false) (let C3956 (if (shen.unlocked? V4373) (let Tm3957 (shen.lazyderef V4369 V4372) (if (cons? Tm3957) (let Tm3958 (shen.lazyderef (hd Tm3957) V4372) (if (cons? Tm3958) (let Tm3959 (shen.lazyderef (hd Tm3958) V4372) (if (cons? Tm3959) (let Tm3960 (shen.lazyderef (hd Tm3959) V4372) (if (= Tm3960 @v) (let Tm3961 (shen.lazyderef (tl Tm3959) V4372) (if (cons? Tm3961) (let X (hd Tm3961) (let Tm3962 (shen.lazyderef (tl Tm3961) V4372) (if (cons? Tm3962) (let Y (hd Tm3962) (let Tm3963 (shen.lazyderef (tl Tm3962) V4372) (if (= Tm3963 ()) (let Tm3964 (shen.lazyderef (tl Tm3958) V4372) (if (cons? Tm3964) (let Colon (hd Tm3964) (let Tm3965 (shen.lazyderef (tl Tm3964) V4372) (if (cons? Tm3965) (let Tm3966 (shen.lazyderef (hd Tm3965) V4372) (if (cons? Tm3966) (let Tm3967 (shen.lazyderef (hd Tm3966) V4372) (if (= Tm3967 vector) (let Tm3968 (shen.lazyderef (tl Tm3966) V4372) (if (cons? Tm3968) (let A (hd Tm3968) (let Tm3969 (shen.lazyderef (tl Tm3968) V4372) (if (= Tm3969 ()) (let Tm3970 (shen.lazyderef (tl Tm3965) V4372) (if (= Tm3970 ()) (let Hyp (tl Tm3957) (do (shen.incinfs) (when (= (shen.deref Colon V4372) (intern ":")) V4372 V4373 K3905 (freeze (shen.cut V4372 V4373 K3905 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons vector (cons A ())) ()))) Hyp)) V4370 true V4372 V4373 K3905 V4375))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3956 false) (let C3971 (if (shen.unlocked? V4373) (let Tm3972 (shen.lazyderef V4369 V4372) (if (cons? Tm3972) (let P (hd Tm3972) (let Hyp (tl Tm3972) (let Tm3973 (shen.lazyderef V4370 V4372) (let GoTo3974 (lambda Q (lambda Normalised (do (shen.incinfs) (bind Q P V4372 V4373 K3905 (freeze (shen.l-rules Hyp Normalised V4371 V4372 V4373 K3905 V4375)))))) (if (cons? Tm3973) (let Q (hd Tm3973) (let Normalised (tl Tm3973) ((GoTo3974 Q) Normalised))) (if (shen.pvar? Tm3973) (let Q (shen.newpv V4372) (shen.gc V4372 (let Normalised (shen.newpv V4372) (shen.gc V4372 (shen.bind! Tm3973 (cons Q Normalised) V4372 (freeze ((GoTo3974 Q) Normalised))))))) false)))))) false)) false) (if (= C3971 false) (shen.unlock V4373 K3905) C3971)) C3956)) C3944)) C3928)) C3913)) C3910))))

(defun shen.t* (V4376 V4377 V4378 V4379 V4380 V4381) (let K3977 (+ V4380 1) (let C3981 (if (shen.unlocked? V4379) (let Tm3982 (shen.lazyderef V4376 V4378) (if (cons? Tm3982) (let Tm3983 (shen.lazyderef (hd Tm3982) V4378) (if (= Tm3983 define) (let Tm3984 (shen.lazyderef (tl Tm3982) V4378) (if (cons? Tm3984) (let F (hd Tm3984) (let X (tl Tm3984) (let SigxRules (shen.newpv V4378) (shen.gc V4378 (let Rules (shen.newpv V4378) (shen.gc V4378 (let FreshSig (shen.newpv V4378) (shen.gc V4378 (let Sig (shen.newpv V4378) (shen.gc V4378 (do (shen.incinfs) (shen.cut V4378 V4379 K3977 (freeze (bind SigxRules (shen.sigxrules (cons F X)) V4378 V4379 K3977 (freeze (bind Sig (fst (shen.lazyderef SigxRules V4378)) V4378 V4379 K3977 (freeze (bind Rules (snd (shen.lazyderef SigxRules V4378)) V4378 V4379 K3977 (freeze (bind FreshSig (shen.freshen-sig (shen.deref Sig V4378)) V4378 V4379 K3977 (freeze (shen.t*-rules F Rules FreshSig 1 V4378 V4379 K3977 (freeze (is Sig V4377 V4378 V4379 K3977 V4381)))))))))))))))))))))))) false)) false)) false)) false) (if (= C3981 false) (shen.unlock V4379 K3977) C3981))))

(defun shen.sigxrules (V4382) (compile (lambda X (shen.<sig*rules> X)) V4382))

(defun shen.<sig*rules> (V4383) (let Result (if (shen.non-empty-stream? V4383) (let F (shen.hds V4383) (let News3986 (shen.tls V4383) (if (shen.=hd? News3986 {) (let News3987 (shen.tls News3986) (let Parseshen.<signature> (shen.<signature> News3987) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News3988 (shen.tls Parseshen.<signature>) (let Parseshen.<rules*> (shen.<rules*> News3988) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (let Rectified (shen.rectify-type (shen.<-out Parseshen.<signature>)) (@p Rectified (shen.<-out Parseshen.<rules*>))))))) (shen.parse-failure))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.freshen-sig (V4384) (let Vs (shen.extract-vars V4384) (let Assoc (map (lambda V (cons V (shen.freshterm (concat & V)))) Vs) (shen.freshen-type Assoc V4384))))

(defun shen.freshen-type (V4385 V4386) (cond ((= () V4385) V4386) ((and (cons? V4385) (cons? (hd V4385))) (shen.freshen-type (tl V4385) (subst (tl (hd V4385)) (hd (hd V4385)) V4386))) (true (shen.f-error shen.freshen-type))))

(defun shen.<rules*> (V4387) (let Result (let Parseshen.<rule*> (shen.<rule*> V4387) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (let Parseshen.<rules*> (shen.<rules*> Parseshen.<rule*>) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) (shen.<-out Parseshen.<rules*>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rule*> (shen.<rule*> V4387) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rule*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rule*> (V4388) (let Result (let Parseshen.<patterns> (shen.<patterns> V4388) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News3991 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News3991) (let Action (shen.hds News3991) (let News3992 (shen.tls News3991) (if (shen.=hd? News3992 where) (let News3993 (shen.tls News3992) (if (shen.non-empty-stream? News3993) (let Guard (shen.hds News3993) (let News3994 (shen.tls News3993) (shen.comb (shen.in-> News3994) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4388) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News3995 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News3995) (let Action (shen.hds News3995) (let News3996 (shen.tls News3995) (if (shen.=hd? News3996 where) (let News3997 (shen.tls News3996) (if (shen.non-empty-stream? News3997) (let Guard (shen.hds News3997) (let News3998 (shen.tls News3997) (shen.comb (shen.in-> News3998) (@p (shen.<-out Parseshen.<patterns>) (shen.correct (cons where (cons Guard (cons Action ())))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4388) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News3999 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News3999) (let Action (shen.hds News3999) (let News4000 (shen.tls News3999) (shen.comb (shen.in-> News4000) (@p (shen.<-out Parseshen.<patterns>) (shen.correct Action))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4388) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News4001 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4001) (let Action (shen.hds News4001) (let News4002 (shen.tls News4001) (shen.comb (shen.in-> News4002) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.correct (V4389) (cond ((and (cons? V4389) (and (= where (hd V4389)) (and (cons? (tl V4389)) (and (cons? (tl (tl V4389))) (and (cons? (hd (tl (tl V4389)))) (and (= fail-if (hd (hd (tl (tl V4389))))) (and (cons? (tl (hd (tl (tl V4389))))) (and (cons? (tl (tl (hd (tl (tl V4389)))))) (and (= () (tl (tl (tl (hd (tl (tl V4389))))))) (= () (tl (tl (tl V4389))))))))))))) (cons where (cons (cons and (cons (hd (tl V4389)) (cons (cons not (cons (tl (hd (tl (tl V4389)))) ())) ()))) (tl (tl (hd (tl (tl V4389)))))))) ((and (cons? V4389) (and (= where (hd V4389)) (and (cons? (tl V4389)) (and (cons? (tl (tl V4389))) (= () (tl (tl (tl V4389)))))))) (cons where (cons (cons and (cons (hd (tl V4389)) (cons (cons not (cons (cons = (cons (hd (tl (tl V4389))) (cons (cons fail ()) ()))) ())) ()))) (tl (tl V4389))))) ((and (cons? V4389) (and (= fail-if (hd V4389)) (and (cons? (tl V4389)) (and (cons? (tl (tl V4389))) (= () (tl (tl (tl V4389)))))))) (cons where (cons (cons not (cons (tl V4389) ())) (tl (tl V4389))))) (true (cons where (cons (cons not (cons (cons = (cons V4389 (cons (cons fail ()) ()))) ())) (cons V4389 ()))))))

(defun shen.t*-rules (V4390 V4391 V4392 V4393 V4394 V4395 V4396 V4397) (let K4005 (+ V4396 1) (let C4011 (if (shen.unlocked? V4395) (let Tm4012 (shen.lazyderef V4391 V4394) (if (= Tm4012 ()) (do (shen.incinfs) (thaw V4397)) false)) false) (if (= C4011 false) (let C4013 (if (shen.unlocked? V4395) (let Tm4014 (shen.lazyderef V4391 V4394) (if (cons? Tm4014) (let Rule (hd Tm4014) (let Rules (tl Tm4014) (let Fresh (shen.newpv V4394) (shen.gc V4394 (do (shen.incinfs) (bind Fresh (shen.freshen-rule (shen.deref Rule V4394)) V4394 V4395 K4005 (freeze (shen.t*-rule V4390 V4393 (fst (shen.lazyderef Fresh V4394)) (snd (shen.lazyderef Fresh V4394)) V4392 V4394 V4395 K4005 (freeze (shen.cut V4394 V4395 K4005 (freeze (shen.t*-rules V4390 Rules V4392 (+ V4393 1) V4394 V4395 K4005 V4397)))))))))))) false)) false) (if (= C4013 false) (shen.unlock V4395 K4005) C4013)) C4011))))

(defun shen.freshen-rule (V4398) (cond ((tuple? V4398) (let Vs (shen.extract-vars (fst V4398)) (let Assoc (map (lambda V (cons V (shen.freshterm V))) Vs) (@p (shen.freshen Assoc (fst V4398)) (shen.freshen Assoc (snd V4398)))))) (true (shen.f-error shen.freshen-rule))))

(defun shen.freshen (V4399 V4400) (cond ((= () V4399) V4400) ((and (cons? V4399) (cons? (hd V4399))) (shen.freshen (tl V4399) (shen.beta (hd (hd V4399)) (tl (hd V4399)) V4400))) (true (shen.f-error shen.freshen))))

(defun shen.t*-rule (V4401 V4402 V4403 V4404 V4405 V4406 V4407 V4408 V4409) (let C4024 (if (shen.unlocked? V4407) (do (shen.incinfs) (shen.t*-rule-h V4403 V4404 V4405 V4406 V4407 V4408 V4409)) false) (if (= C4024 false) (if (shen.unlocked? V4407) (let Err (shen.newpv V4406) (shen.gc V4406 (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app V4402 (cn " of " (shen.app V4401 "
" shen.a)) shen.a))) V4406 V4407 V4408 V4409)))) false) C4024)))

(defun shen.t*-rule-h (V4410 V4411 V4412 V4413 V4414 V4415 V4416) (let K4027 (+ V4415 1) (let C4032 (if (shen.unlocked? V4414) (let Tm4033 (shen.lazyderef V4410 V4413) (if (= Tm4033 ()) (let Tm4034 (shen.lazyderef V4412 V4413) (if (cons? Tm4034) (let Tm4035 (shen.lazyderef (hd Tm4034) V4413) (if (= Tm4035 -->) (let Tm4036 (shen.lazyderef (tl Tm4034) V4413) (if (cons? Tm4036) (let A (hd Tm4036) (let Tm4037 (shen.lazyderef (tl Tm4036) V4413) (if (= Tm4037 ()) (do (shen.incinfs) (shen.cut V4413 V4414 K4027 (freeze (shen.t*-correct V4411 A () V4413 V4414 K4027 V4416)))) false))) false)) false)) false)) false)) false) (if (= C4032 false) (let C4038 (if (shen.unlocked? V4414) (let B (shen.newpv V4413) (shen.gc V4413 (let Hyps (shen.newpv V4413) (shen.gc V4413 (do (shen.incinfs) (shen.t*-integrity V4410 V4412 Hyps B V4413 V4414 K4027 (freeze (shen.cut V4413 V4414 K4027 (freeze (shen.t*-correct V4411 B Hyps V4413 V4414 K4027 V4416)))))))))) false) (if (= C4038 false) (shen.unlock V4414 K4027) C4038)) C4032))))

(defun shen.t*-correct (V4417 V4418 V4419 V4420 V4421 V4422 V4423) (let K4041 (+ V4422 1) (let C4046 (if (shen.unlocked? V4421) (let Tm4047 (shen.lazyderef V4417 V4420) (if (cons? Tm4047) (let Tm4048 (shen.lazyderef (hd Tm4047) V4420) (if (= Tm4048 where) (let Tm4049 (shen.lazyderef (tl Tm4047) V4420) (if (cons? Tm4049) (let G (hd Tm4049) (let Tm4050 (shen.lazyderef (tl Tm4049) V4420) (if (cons? Tm4050) (let R (hd Tm4050) (let Tm4051 (shen.lazyderef (tl Tm4050) V4420) (if (= Tm4051 ()) (let CurryG (shen.newpv V4420) (shen.gc V4420 (do (shen.incinfs) (shen.cut V4420 V4421 K4041 (freeze (bind CurryG (shen.curry G) V4420 V4421 K4041 (freeze (shen.system-S-h CurryG boolean V4419 V4420 V4421 K4041 (freeze (shen.cut V4420 V4421 K4041 (freeze (shen.t*-correct R V4418 (cons (cons CurryG (cons (intern ":") (cons verified ()))) V4419) V4420 V4421 K4041 V4423)))))))))))) false))) false))) false)) false)) false)) false) (if (= C4046 false) (let C4052 (if (shen.unlocked? V4421) (do (shen.incinfs) (shen.system-S-h (shen.curry V4417) V4418 V4419 V4420 V4421 K4041 V4423)) false) (if (= C4052 false) (shen.unlock V4421 K4041) C4052)) C4046))))

(defun shen.t*-integrity (V4424 V4425 V4426 V4427 V4428 V4429 V4430 V4431) (let K4056 (+ V4430 1) (let C4062 (if (shen.unlocked? V4429) (let Tm4063 (shen.lazyderef V4424 V4428) (if (= Tm4063 ()) (let Tm4064 (shen.lazyderef V4426 V4428) (let GoTo4065 (freeze (do (shen.incinfs) (is! V4425 V4427 V4428 V4429 K4056 V4431))) (if (= Tm4064 ()) (thaw GoTo4065) (if (shen.pvar? Tm4064) (shen.bind! Tm4064 () V4428 GoTo4065) false)))) false)) false) (if (= C4062 false) (let C4066 (if (shen.unlocked? V4429) (let Tm4067 (shen.lazyderef V4424 V4428) (if (cons? Tm4067) (let P (hd Tm4067) (let Ps (tl Tm4067) (let Tm4068 (shen.lazyderef V4425 V4428) (if (cons? Tm4068) (let A (hd Tm4068) (let Tm4069 (shen.lazyderef (tl Tm4068) V4428) (if (cons? Tm4069) (let Tm4070 (shen.lazyderef (hd Tm4069) V4428) (if (= Tm4070 -->) (let Tm4071 (shen.lazyderef (tl Tm4069) V4428) (if (cons? Tm4071) (let B (hd Tm4071) (let Tm4072 (shen.lazyderef (tl Tm4071) V4428) (if (= Tm4072 ()) (let Tm4073 (shen.lazyderef V4426 V4428) (let GoTo4074 (lambda Hyp (lambda Hyps (let PHyps (shen.newpv V4428) (shen.gc V4428 (do (shen.incinfs) (bind Hyp (cons P (cons (intern ":") (cons A ()))) V4428 V4429 K4056 (freeze (shen.p-hyps P PHyps V4428 V4429 K4056 (freeze (shen.cut V4428 V4429 K4056 (freeze (shen.system-S-h P A PHyps V4428 V4429 K4056 (freeze (shen.cut V4428 V4429 K4056 (freeze (shen.t*-integrity Ps B Hyps V4427 V4428 V4429 K4056 V4431)))))))))))))))) (if (cons? Tm4073) (let Hyp (hd Tm4073) (let Hyps (tl Tm4073) ((GoTo4074 Hyp) Hyps))) (if (shen.pvar? Tm4073) (let Hyp (shen.newpv V4428) (shen.gc V4428 (let Hyps (shen.newpv V4428) (shen.gc V4428 (shen.bind! Tm4073 (cons Hyp Hyps) V4428 (freeze ((GoTo4074 Hyp) Hyps))))))) false)))) false))) false)) false)) false))) false)))) false)) false) (if (= C4066 false) (shen.unlock V4429 K4056) C4066)) C4062))))

(defun shen.p-hyps (V4432 V4433 V4434 V4435 V4436 V4437) (let K4077 (+ V4436 1) (let C4081 (if (shen.unlocked? V4435) (let A (shen.newpv V4434) (shen.gc V4434 (do (shen.incinfs) (when (shen.freshterm? (shen.deref V4432 V4434)) V4434 V4435 K4077 (freeze (shen.cut V4434 V4435 K4077 (freeze (bind V4433 (cons (cons V4432 (cons (intern ":") (cons A ()))) ()) V4434 V4435 K4077 V4437)))))))) false) (if (= C4081 false) (let C4082 (if (shen.unlocked? V4435) (let Tm4083 (shen.lazyderef V4432 V4434) (if (cons? Tm4083) (let X (hd Tm4083) (let Y (tl Tm4083) (let XHyps (shen.newpv V4434) (shen.gc V4434 (let YHyps (shen.newpv V4434) (shen.gc V4434 (do (shen.incinfs) (shen.cut V4434 V4435 K4077 (freeze (shen.p-hyps X XHyps V4434 V4435 K4077 (freeze (shen.p-hyps Y YHyps V4434 V4435 K4077 (freeze (shen.join XHyps YHyps V4433 V4434 V4435 K4077 V4437)))))))))))))) false)) false) (if (= C4082 false) (let C4084 (if (shen.unlocked? V4435) (do (shen.incinfs) (bind V4433 () V4434 V4435 K4077 V4437)) false) (if (= C4084 false) (shen.unlock V4435 K4077) C4084)) C4082)) C4081))))

(defun shen.freshterm? (V4438) (and (absvector? V4438) (and (not (string? V4438)) (= (<-address V4438 0) shen.print-freshterm))))

(defun shen.join (V4439 V4440 V4441 V4442 V4443 V4444 V4445) (let C4092 (if (shen.unlocked? V4443) (let Tm4093 (shen.lazyderef V4439 V4442) (if (= Tm4093 ()) (do (shen.incinfs) (bind V4441 V4440 V4442 V4443 V4444 V4445)) false)) false) (if (= C4092 false) (if (shen.unlocked? V4443) (let Tm4094 (shen.lazyderef V4439 V4442) (if (cons? Tm4094) (let X (hd Tm4094) (let Y (tl Tm4094) (let Tm4095 (shen.lazyderef V4441 V4442) (let GoTo4096 (lambda X* (lambda Z (do (shen.incinfs) (bind X* X V4442 V4443 V4444 (freeze (shen.join Y V4440 Z V4442 V4443 V4444 V4445)))))) (if (cons? Tm4095) (let X* (hd Tm4095) (let Z (tl Tm4095) ((GoTo4096 X*) Z))) (if (shen.pvar? Tm4095) (let X* (shen.newpv V4442) (shen.gc V4442 (let Z (shen.newpv V4442) (shen.gc V4442 (shen.bind! Tm4095 (cons X* Z) V4442 (freeze ((GoTo4096 X*) Z))))))) false)))))) false)) false) C4092)))

