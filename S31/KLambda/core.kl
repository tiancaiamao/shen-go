(defun shen.shen->kl (V1447) (let KL (shen.shen->kl-h V1447) (shen.record-and-evaluate KL)))

(defun shen.record-and-evaluate (V1448) (cond ((and (cons? V1448) (and (= defun (hd V1448)) (and (cons? (tl V1448)) (and (cons? (tl (tl V1448))) (and (cons? (tl (tl (tl V1448)))) (= () (tl (tl (tl (tl V1448)))))))))) (let SysfuncChk (if (shen.sysfunc? (hd (tl V1448))) (simple-error (shen.app (hd (tl V1448)) " is not a legitimate function name
" shen.a)) shen.skip) (let Arity (shen.store-arity (hd (tl V1448)) (length (hd (tl (tl V1448))))) (let Record (shen.record-kl (hd (tl V1448)) V1448) (let Eval (eval-kl V1448) (shen.fn-print (hd (tl V1448)))))))) (true V1448)))

(defun shen.shen->kl-h (V1449) (cond ((and (cons? V1449) (and (= define (hd V1449)) (cons? (tl V1449)))) (shen.shendef->kldef (hd (tl V1449)) (tl (tl V1449)))) ((and (cons? V1449) (and (= defun (hd V1449)) (and (cons? (tl V1449)) (and (cons? (tl (tl V1449))) (and (cons? (tl (tl (tl V1449)))) (= () (tl (tl (tl (tl V1449)))))))))) V1449) ((and (cons? V1449) (and (= type (hd V1449)) (and (cons? (tl V1449)) (and (cons? (tl (tl V1449))) (= () (tl (tl (tl V1449)))))))) (cons type (cons (hd (tl V1449)) (cons (shen.rcons_form (hd (tl (tl V1449)))) ())))) ((and (cons? V1449) (and (= input+ (hd V1449)) (and (cons? (tl V1449)) (and (cons? (tl (tl V1449))) (= () (tl (tl (tl V1449)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1449))) (tl (tl V1449))))) ((cons? V1449) (map (lambda Z (shen.shen->kl-h Z)) V1449)) (true V1449)))

(defun shen.shendef->kldef (V1450 V1451) (compile (lambda X (shen.<define> X)) (cons V1450 V1451)))

(defun shen.<define> (V1452) (let Result (let Parseshen.<name> (shen.<name> V1452) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (if (shen.=hd? Parseshen.<name> {) (let News1313 (shen.tls Parseshen.<name>) (let Parseshen.<signature> (shen.<signature> News1313) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News1314 (shen.tls Parseshen.<signature>) (let Parseshen.<rules> (shen.<rules> News1314) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<name> (shen.<name> V1452) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<name>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.shendef->kldef-h (V1453 V1454) (let Ps (map (lambda X (fst X)) V1454) (let Arity (shen.arity-chk V1453 Ps) (let FreeVarChk (map (lambda R (shen.free-var-chk V1453 R)) V1454) (let KL (shen.factorise-code (shen.compile-to-kl V1453 V1454 Arity)) KL)))))

(defun shen.<name> (V1455) (let Result (if (shen.non-empty-stream? V1455) (let X (shen.hds V1455) (let News1316 (shen.tls V1455) (shen.comb (shen.in-> News1316) (if (and (symbol? X) (not (variable? X))) X (simple-error (shen.app X " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<signature> (V1456) (let Result (if (shen.non-empty-stream? V1456) (let X (shen.hds V1456) (let News1318 (shen.tls V1456) (let Parseshen.<signature> (shen.<signature> News1318) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (not (element? X (cons { (cons } ())))) (shen.comb (shen.in-> Parseshen.<signature>) (cons X (shen.<-out Parseshen.<signature>))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V1456) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rules> (V1457) (let Result (let Parseshen.<rule> (shen.<rule> V1457) (if (shen.parse-failure? Parseshen.<rule>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<rule>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (cons (shen.linearise (shen.<-out Parseshen.<rule>)) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V1457) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.linearise (V1460) (cond ((tuple? V1460) (shen.linearise-h (fst V1460) (fst V1460) () (snd V1460))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V1473 V1474 V1475 V1476) (cond ((= () V1473) (@p V1474 V1476)) ((and (cons? V1473) (cons? (hd V1473))) (shen.linearise-h (append (hd V1473) (tl V1473)) V1474 V1475 V1476)) ((and (cons? V1473) (variable? (hd V1473))) (if (element? (hd V1473) V1475) (let Z (gensym (protect V)) (shen.linearise-h (tl V1473) (shen.rep-X (hd V1473) Z V1474) V1475 (cons where (cons (cons = (cons Z (cons (hd V1473) ()))) (cons V1476 ()))))) (shen.linearise-h (tl V1473) V1474 (cons (hd V1473) V1475) V1476))) ((cons? V1473) (shen.linearise-h (tl V1473) V1474 V1475 V1476)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V1477) (let Result (let Parseshen.<patterns> (shen.<patterns> V1477) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News1321 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1321) (let Action (shen.hds News1321) (let News1322 (shen.tls News1321) (if (shen.=hd? News1322 where) (let News1323 (shen.tls News1322) (if (shen.non-empty-stream? News1323) (let Guard (shen.hds News1323) (let News1324 (shen.tls News1323) (shen.comb (shen.in-> News1324) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1477) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News1325 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1325) (let Action (shen.hds News1325) (let News1326 (shen.tls News1325) (shen.comb (shen.in-> News1326) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1477) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News1327 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1327) (let Action (shen.hds News1327) (let News1328 (shen.tls News1327) (if (shen.=hd? News1328 where) (let News1329 (shen.tls News1328) (if (shen.non-empty-stream? News1329) (let Guard (shen.hds News1329) (let News1330 (shen.tls News1329) (shen.comb (shen.in-> News1330) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons (cons shen.choicepoint! (cons Action ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1477) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News1331 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1331) (let Action (shen.hds News1331) (let News1332 (shen.tls News1331) (shen.comb (shen.in-> News1332) (@p (shen.<-out Parseshen.<patterns>) (cons shen.choicepoint! (cons Action ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<patterns> (V1478) (let Result (let Parseshen.<pattern> (shen.<pattern> V1478) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (let Parseshen.<patterns> (shen.<patterns> Parseshen.<pattern>) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<patterns>) (cons (shen.<-out Parseshen.<pattern>) (shen.<-out Parseshen.<patterns>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V1478) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern> (V1479) (let Result (if (shen.ccons? V1479) (let SynCons (shen.comb (shen.hds V1479) (shen.<-out V1479)) (let Parseshen.<constructor> (shen.<constructor> SynCons) (if (shen.parse-failure? Parseshen.<constructor>) (shen.parse-failure) (let Parseshen.<pattern1> (shen.<pattern1> Parseshen.<constructor>) (if (shen.parse-failure? Parseshen.<pattern1>) (shen.parse-failure) (let Parseshen.<pattern2> (shen.<pattern2> Parseshen.<pattern1>) (if (shen.parse-failure? Parseshen.<pattern2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<pattern2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1479)) (cons (shen.<-out Parseshen.<constructor>) (cons (shen.<-out Parseshen.<pattern1>) (cons (shen.<-out Parseshen.<pattern2>) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V1479) (let SynCons (shen.comb (shen.hds V1479) (shen.<-out V1479)) (if (shen.=hd? SynCons vector) (let News1335 (shen.tls SynCons) (if (shen.=hd? News1335 0) (let News1336 (shen.tls News1335) (let Parseshen.<end> (shen.<end> News1336) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1479)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V1479) (let X (shen.hds V1479) (let News1337 (shen.tls V1479) (if (cons? X) (shen.comb (shen.in-> News1337) (shen.constructor-error X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<simple-pattern> (shen.<simple-pattern> V1479) (if (shen.parse-failure? Parseshen.<simple-pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<simple-pattern>) (shen.<-out Parseshen.<simple-pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<constructor> (V1480) (let Result (if (shen.non-empty-stream? V1480) (let C (shen.hds V1480) (let News1339 (shen.tls V1480) (if (shen.constructor? C) (shen.comb (shen.in-> News1339) C) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.constructor? (V1481) (element? V1481 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V1482) (simple-error (shen.app V1482 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V1483) (let Result (if (shen.non-empty-stream? V1483) (let X (shen.hds V1483) (let News1341 (shen.tls V1483) (if (= X _) (shen.comb (shen.in-> News1341) (gensym (protect Y))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V1483) (let X (shen.hds V1483) (let News1342 (shen.tls V1483) (if (not (element? X (cons -> (cons <- ())))) (shen.comb (shen.in-> News1342) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern1> (V1484) (let Result (let Parseshen.<pattern> (shen.<pattern> V1484) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<pattern2> (V1485) (let Result (let Parseshen.<pattern> (shen.<pattern> V1485) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.fn-print (V1486) (let V (absvector 2) (let Print (address-> V 0 shen.printF) (let Named (address-> Print 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V1486) ")")))))) Named))))

(defun shen.printF (V1487) (<-address V1487 1))

(defun shen.arity-chk (V1492 V1493) (cond ((and (cons? V1493) (= () (tl V1493))) (length (hd V1493))) ((and (cons? V1493) (and (cons? (tl V1493)) (= (length (hd V1493)) (length (hd (tl V1493)))))) (shen.arity-chk V1492 (tl V1493))) (true (simple-error (cn "arity error in " (shen.app V1492 "
" shen.a))))))

(defun shen.free-var-chk (V1494 V1495) (cond ((tuple? V1495) (shen.free-variable-error-message V1494 (shen.find-free-vars (shen.extract-vars (fst V1495)) (snd V1495)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V1496 V1497) (if (empty? V1497) shen.skip (do (pr (cn "free variables in " (shen.app V1496 ":" shen.a)) (stoutput)) (do (map (lambda X (pr (cn " " (shen.app X "" shen.a)) (stoutput))) V1497) (do (nl 1) (abort))))))

(defun shen.extract-vars (V1500) (cond ((variable? V1500) (cons V1500 ())) ((cons? V1500) (union (shen.extract-vars (hd V1500)) (shen.extract-vars (tl V1500)))) (true ())))

(defun shen.find-free-vars (V1505 V1506) (cond ((and (cons? V1506) (and (= protect (hd V1506)) (and (cons? (tl V1506)) (= () (tl (tl V1506)))))) ()) ((and (cons? V1506) (and (= let (hd V1506)) (and (cons? (tl V1506)) (and (cons? (tl (tl V1506))) (and (cons? (tl (tl (tl V1506)))) (= () (tl (tl (tl (tl V1506)))))))))) (union (shen.find-free-vars V1505 (hd (tl (tl V1506)))) (shen.find-free-vars (cons (hd (tl V1506)) V1505) (hd (tl (tl (tl V1506))))))) ((and (cons? V1506) (and (= lambda (hd V1506)) (and (cons? (tl V1506)) (and (cons? (tl (tl V1506))) (= () (tl (tl (tl V1506)))))))) (shen.find-free-vars (cons (hd (tl V1506)) V1505) (hd (tl (tl V1506))))) ((cons? V1506) (union (shen.find-free-vars V1505 (hd V1506)) (shen.find-free-vars V1505 (tl V1506)))) ((shen.free-variable? V1506 V1505) (cons V1506 ())) (true ())))

(defun shen.free-variable? (V1507 V1508) (and (variable? V1507) (not (element? V1507 V1508))))

(defun shen.record-kl (V1509 V1510) (put V1509 shen.source V1510 (value *property-vector*)))

(defun shen.compile-to-kl (V1511 V1512 V1513) (let Parameters (shen.parameters V1513) (let Body (shen.scan-body V1511 (shen.kl-body V1512 Parameters)) (let Defun (cons defun (cons V1511 (cons Parameters (cons (shen.cond-form Body) ())))) Defun))))

(defun shen.parameters (V1514) (cond ((= 0 V1514) ()) (true (cons (gensym (protect V)) (shen.parameters (- V1514 1))))))

(defun shen.cond-form (V1517) (cond ((and (cons? V1517) (and (cons? (hd V1517)) (and (= true (hd (hd V1517))) (and (cons? (tl (hd V1517))) (= () (tl (tl (hd V1517)))))))) (hd (tl (hd V1517)))) (true (cons cond V1517))))

(defun shen.scan-body (V1526 V1527) (cond ((= () V1527) (cons (cons true (cons (cons shen.f-error (cons V1526 ())) ())) ())) ((and (cons? V1527) (shen.choicepoint? (hd V1527))) (shen.choicepoint V1526 (gensym (protect Freeze)) (gensym (protect Result)) (hd V1527) (tl V1527))) ((and (cons? V1527) (and (cons? (hd V1527)) (and (= true (hd (hd V1527))) (and (cons? (tl (hd V1527))) (= () (tl (tl (hd V1527)))))))) (cons (hd V1527) ())) ((cons? V1527) (cons (hd V1527) (shen.scan-body V1526 (tl V1527)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V1534) (cond ((and (cons? V1534) (and (cons? (tl V1534)) (and (cons? (hd (tl V1534))) (and (= shen.choicepoint! (hd (hd (tl V1534)))) (and (cons? (tl (hd (tl V1534)))) (and (= () (tl (tl (hd (tl V1534))))) (= () (tl (tl V1534))))))))) true) (true false)))

(defun shen.choicepoint (V1550 V1551 V1552 V1553 V1554) (cond ((and (cons? V1553) (and (cons? (tl V1553)) (and (cons? (hd (tl V1553))) (and (cons? (tl (hd (tl V1553)))) (and (cons? (hd (tl (hd (tl V1553))))) (and (= fail-if (hd (hd (tl (hd (tl V1553)))))) (and (cons? (tl (hd (tl (hd (tl V1553)))))) (and (cons? (tl (tl (hd (tl (hd (tl V1553))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V1553)))))))) (and (= () (tl (tl (hd (tl V1553))))) (and (= () (tl (tl V1553))) (= V1550 (hd (tl (hd (tl (hd (tl V1553)))))))))))))))))) (cons (cons true (cons (cons let (cons V1551 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V1553)))))) V1554)) ())) (cons (cons if (cons (hd V1553) (cons (cons let (cons V1552 (cons (hd (tl (tl (hd (tl (hd (tl V1553))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V1553)))))) (cons V1552 ())) (cons (cons thaw (cons V1551 ())) (cons V1552 ())))) ())))) (cons (cons thaw (cons V1551 ())) ())))) ())))) ())) ())) ((and (cons? V1553) (and (cons? (tl V1553)) (and (cons? (hd (tl V1553))) (and (cons? (tl (hd (tl V1553)))) (and (= () (tl (tl (hd (tl V1553))))) (= () (tl (tl V1553)))))))) (cons (cons true (cons (cons let (cons V1551 (cons (cons freeze (cons (cons cond (shen.scan-body V1550 V1554)) ())) (cons (cons if (cons (hd V1553) (cons (cons let (cons V1552 (cons (hd (tl (hd (tl V1553)))) (cons (cons if (cons (cons = (cons V1552 (cons (cons fail ()) ()))) (cons (cons thaw (cons V1551 ())) (cons V1552 ())))) ())))) (cons (cons thaw (cons V1551 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V1556 V1557 V1558) (cond ((= V1556 V1558) V1557) ((cons? V1558) (let Rep (shen.rep-X V1556 V1557 (hd V1558)) (if (= Rep (hd V1558)) (cons (hd V1558) (shen.rep-X V1556 V1557 (tl V1558))) (cons Rep (tl V1558))))) (true V1558)))

(defun shen.kl-body (V1559 V1560) (map (lambda R (shen.triple-stack () (fst R) V1560 (snd R))) V1559))

(defun shen.triple-stack (V1569 V1570 V1571 V1572) (cond ((and (= () V1570) (and (= () V1571) (and (cons? V1572) (and (= where (hd V1572)) (and (cons? (tl V1572)) (and (cons? (tl (tl V1572))) (= () (tl (tl (tl V1572)))))))))) (shen.triple-stack (cons (hd (tl V1572)) V1569) () () (hd (tl (tl V1572))))) ((and (= () V1570) (= () V1571)) (cons (shen.rectify-test (reverse V1569)) (cons V1572 ()))) ((and (cons? V1570) (and (cons? V1571) (variable? (hd V1570)))) (shen.triple-stack V1569 (tl V1570) (tl V1571) (shen.beta (hd V1570) (hd V1571) V1572))) ((and (cons? V1570) (and (cons? (hd V1570)) (and (cons? (tl (hd V1570))) (and (cons? (tl (tl (hd V1570)))) (and (= () (tl (tl (tl (hd V1570))))) (cons? V1571)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V1570))) (cons (hd V1571) ())) V1569) (cons (hd (tl (hd V1570))) (cons (hd (tl (tl (hd V1570)))) (tl V1570))) (cons (cons (shen.op1 (hd (hd V1570))) (cons (hd V1571) ())) (cons (cons (shen.op2 (hd (hd V1570))) (cons (hd V1571) ())) (tl V1571))) (shen.beta (hd V1570) (hd V1571) V1572))) ((and (cons? V1570) (cons? V1571)) (shen.triple-stack (cons (cons = (cons (hd V1570) (cons (hd V1571) ()))) V1569) (tl V1570) (tl V1571) V1572)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V1575) (cond ((= () V1575) true) ((and (cons? V1575) (= () (tl V1575))) (hd V1575)) ((and (cons? V1575) (cons? (tl V1575))) (cons and (cons (hd V1575) (cons (shen.rectify-test (tl V1575)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V1585 V1586 V1587) (cond ((= V1585 V1587) V1586) ((and (cons? V1587) (and (= lambda (hd V1587)) (and (cons? (tl V1587)) (and (cons? (tl (tl V1587))) (and (= () (tl (tl (tl V1587)))) (= V1585 (hd (tl V1587)))))))) V1587) ((and (cons? V1587) (and (= let (hd V1587)) (and (cons? (tl V1587)) (and (cons? (tl (tl V1587))) (and (cons? (tl (tl (tl V1587)))) (and (= () (tl (tl (tl (tl V1587))))) (= V1585 (hd (tl V1587))))))))) (cons let (cons (hd (tl V1587)) (cons (shen.beta (hd (tl V1587)) V1586 (hd (tl (tl V1587)))) (tl (tl (tl V1587))))))) ((cons? V1587) (map (lambda V (shen.beta V1585 V1586 V)) V1587)) (true V1587)))

(defun shen.op1 (V1590) (cond ((= cons V1590) hd) ((= @s V1590) hdstr) ((= @p V1590) fst) ((= @v V1590) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V1593) (cond ((= cons V1593) tl) ((= @s V1593) tlstr) ((= @p V1593) snd) ((= @v V1593) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V1596) (cond ((= cons V1596) cons?) ((= @s V1596) shen.+string?) ((= @p V1596) tuple?) ((= @v V1596) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V1597) (cond ((= "" V1597) false) (true (string? V1597))))

(defun shen.+vector? (V1598) (cond ((= V1598 (vector 0)) false) (true (vector? V1598))))

(defun factorise (V1601) (cond ((= + V1601) (set shen.*factorise?* true)) ((= - V1601) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V1602) (cond ((and (cons? V1602) (and (= defun (hd V1602)) (and (cons? (tl V1602)) (and (cons? (tl (tl V1602))) (and (cons? (tl (tl (tl V1602)))) (and (cons? (hd (tl (tl (tl V1602))))) (and (= cond (hd (hd (tl (tl (tl V1602)))))) (and (= () (tl (tl (tl (tl V1602))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V1602)) (cons (hd (tl (tl V1602))) (cons (shen.vertical (hd (tl (tl V1602))) (tl (hd (tl (tl (tl V1602))))) (cons shen.f-error (cons (hd (tl V1602)) ()))) ()))))) (true V1602)))

(defun shen.vertical (V1615 V1616 V1617) (cond ((and (cons? V1616) (and (cons? (hd V1616)) (and (= true (hd (hd V1616))) (and (cons? (tl (hd V1616))) (= () (tl (tl (hd V1616)))))))) (hd (tl (hd V1616)))) ((= () V1616) V1617) ((and (cons? V1616) (and (cons? (hd V1616)) (and (cons? (hd (hd V1616))) (and (= and (hd (hd (hd V1616)))) (and (cons? (tl (hd (hd V1616)))) (and (cons? (tl (tl (hd (hd V1616))))) (and (= () (tl (tl (tl (hd (hd V1616)))))) (and (cons? (tl (hd V1616))) (= () (tl (tl (hd V1616)))))))))))) (let Before+After (shen.split-cases (hd (tl (hd (hd V1616)))) V1616 ()) (shen.branch (hd (tl (hd (hd V1616)))) V1615 Before+After V1617))) ((and (cons? V1616) (and (cons? (hd V1616)) (and (cons? (tl (hd V1616))) (= () (tl (tl (hd V1616))))))) (cons if (cons (hd (hd V1616)) (cons (hd (tl (hd V1616))) (cons (shen.vertical V1615 (tl V1616) V1617) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V1622 V1623 V1624) (cond ((and (cons? V1623) (and (cons? (hd V1623)) (and (cons? (hd (hd V1623))) (and (= and (hd (hd (hd V1623)))) (and (cons? (tl (hd (hd V1623)))) (and (cons? (tl (tl (hd (hd V1623))))) (and (= () (tl (tl (tl (hd (hd V1623)))))) (and (cons? (tl (hd V1623))) (and (= () (tl (tl (hd V1623)))) (= V1622 (hd (tl (hd (hd V1623)))))))))))))) (shen.split-cases (hd (tl (hd (hd V1623)))) (tl V1623) (cons (cons (hd (tl (tl (hd (hd V1623))))) (tl (hd V1623))) V1624))) ((and (cons? V1623) (and (cons? (hd V1623)) (and (cons? (tl (hd V1623))) (and (= () (tl (tl (hd V1623)))) (= V1622 (hd (hd V1623))))))) (shen.split-cases (hd (hd V1623)) (tl V1623) (cons (cons true (tl (hd V1623))) V1624))) (true (cons (reverse V1624) (cons V1623 ())))))

(defun shen.branch (V1625 V1626 V1627 V1628) (cond ((and (cons? V1627) (and (cons? (tl V1627)) (= () (tl (tl V1627))))) (let Else (shen.else V1626 (hd (tl V1627)) V1628) (let Then (shen.then V1625 V1626 (hd V1627) Else) (cons if (cons V1625 (cons Then (cons Else ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V1629 V1630 V1631) (let Else (shen.vertical V1629 V1630 V1631) (if (shen.inline? Else) Else (shen.procedure-call V1629 Else))))

(defun shen.procedure-call (V1632 V1633) (let F (gensym shen.else) (let Used (shen.remove-if-unused V1632 V1633) (let KL (cons defun (cons F (cons Used (cons V1633 ())))) (let EvalKL (eval-kl KL) (let Record (shen.record-kl F KL) (cons F Used)))))))

(defun shen.remove-if-unused (V1640 V1641) (cond ((= () V1640) ()) ((cons? V1640) (if (shen.occurs? (hd V1640) V1641) (cons (hd V1640) (shen.remove-if-unused (tl V1640) V1641)) (shen.remove-if-unused (tl V1640) V1641))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V1642 V1643 V1644 V1645) (shen.horizontal (shen.selectors V1642 V1644) V1643 V1644 V1645))

(defun shen.horizontal (V1654 V1655 V1656 V1657) (cond ((= () V1654) (shen.vertical V1655 V1656 V1657)) ((cons? V1654) (let V (gensym (protect V)) (cons let (cons V (cons (hd V1654) (cons (shen.horizontal (tl V1654) (cons V V1655) (subst V (hd V1654) V1656) V1657) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V1662 V1663) (cond ((and (cons? V1662) (and (cons? (tl V1662)) (and (= () (tl (tl V1662))) (shen.constructor? (shen.op (hd V1662)))))) (let Op (shen.op (hd V1662)) (let Hd (cons (shen.op1 Op) (tl V1662)) (let Tl (cons (shen.op2 Op) (tl V1662)) (let RptedHd? (shen.rpted? Hd V1663) (let RptedTl? (shen.rpted? Tl V1663) (if (and RptedHd? RptedTl?) (cons Hd (cons Tl ())) (if RptedHd? (cons Hd ()) (if RptedTl? (cons Tl ()) ()))))))))) (true ())))

(defun shen.rpted? (V1664 V1665) (> (occurrences V1664 V1665) 1))

(defun shen.inline? (V1666) (cond ((cons? V1666) (and (atom? (hd V1666)) (shen.inline? (tl V1666)))) (true (atom? V1666))))

(defun shen.op (V1669) (cond ((= cons? V1669) cons) ((= shen.+string? V1669) @s) ((= shen.+vector? V1669) @v) ((= tuple? V1669) @p) (true shen.skip)))

