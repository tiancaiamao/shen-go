(defun read-file (V2726) (let Bytelist (read-file-as-bytelist V2726) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) Bytelist) (lambda E (shen.print-residue (value shen.*residue*)))) (let Process (shen.process-sexprs S-exprs) Process))))

(defun shen.print-residue (V2727) (let Err (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V2727)))

(defun shen.nchars (V2732 V2733) (cond ((= 0 V2732) (do (pr " ..." (stoutput)) (abort))) ((= () V2733) (do (pr " ..." (stoutput)) (abort))) ((cons? V2733) (do (pr (n->string (hd V2733)) (stoutput)) (shen.nchars (- V2732 1) (tl V2733)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V2734) (let Stream (open V2734 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V2735 V2736 V2737) (cond ((= -1 V2736) V2737) (true (shen.read-file-as-bytelist-help V2735 (read-byte V2735) (cons V2736 V2737)))))

(defun read-file-as-string (V2738) (let Stream (open V2738 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V2739 V2740 V2741) (cond ((= -1 V2740) (do (close V2739) V2741)) (true (shen.rfas-h V2739 (read-byte V2739) (cn V2741 (n->string V2740))))))

(defun input (V2742) (eval-kl (read V2742)))

(defun input+ (V2743 V2744) (let Mono? (shen.monotype V2743) (let Input (read V2744) (if (= false (shen.typecheck Input (shen.rectify-type V2743))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V2743 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V2745) (cond ((cons? V2745) (map (lambda Z (shen.monotype Z)) V2745)) (true (if (variable? V2745) (simple-error (cn "input+ expects a monotype: not " (shen.app V2745 "
" shen.a))) V2745))))

(defun lineread (V2746) (shen.read-loop V2746 (shen.my-read-byte V2746) () (lambda X (shen.return? X))))

(defun read-from-string (V2747) (let Bytelist (shen.str->bytes V2747) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) (let Process (shen.process-sexprs S-exprs) Process))))

(defun read-from-string-unprocessed (V2748) (let Bytelist (shen.str->bytes V2748) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) S-exprs)))

(defun shen.str->bytes (V2749) (cond ((= "" V2749) ()) ((shen.+string? V2749) (cons (string->n (hdstr V2749)) (shen.str->bytes (tlstr V2749)))) (true (shen.f-error shen.str->bytes))))

(defun read (V2750) (hd (shen.read-loop V2750 (shen.my-read-byte V2750) () (lambda X (shen.whitespace? X)))))

(defun shen.my-read-byte (V2751) (if (shen.char-stinput? V2751) (string->n (shen.read-unit-string V2751)) (read-byte V2751)))

(defun shen.read-loop (V2756 V2757 V2758 V2759) (cond ((= 94 V2757) (simple-error "read aborted")) ((= -1 V2757) (if (empty? V2758) (simple-error "error: empty stream") (compile (lambda X (shen.<s-exprs> X)) V2758))) ((= 0 V2757) (shen.read-loop V2756 (shen.my-read-byte V2756) V2758 V2759)) (true (if (V2759 V2757) (let Parse (shen.try-parse V2758) (if (shen.nothing-doing? Parse) (shen.read-loop V2756 (shen.my-read-byte V2756) (append V2758 (cons V2757 ())) V2759) (do (shen.record-it V2758) Parse))) (shen.read-loop V2756 (shen.my-read-byte V2756) (append V2758 (cons V2757 ())) V2759)))))

(defun shen.try-parse (V2760) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) V2760) (lambda E shen.i-failed!)) (if (shen.nothing-doing? S-exprs) shen.i-failed! (shen.process-sexprs S-exprs))))

(defun shen.nothing-doing? (V2763) (cond ((= shen.i-failed! V2763) true) ((= () V2763) true) (true false)))

(defun shen.record-it (V2764) (set shen.*it* (shen.bytes->string V2764)))

(defun shen.bytes->string (V2765) (cond ((= () V2765) "") ((cons? V2765) (cn (n->string (hd V2765)) (shen.bytes->string (tl V2765)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V2766) (let Unpack&Expand (shen.unpackage&macroexpand V2766) (let FindArities (shen.find-arities Unpack&Expand) (let Types (shen.find-types Unpack&Expand) (map (lambda X (shen.process-applications X Types)) Unpack&Expand)))))

(defun shen.find-types (V2767) (cond ((and (cons? V2767) (and (cons? (tl V2767)) (= (hd V2767) (intern ":")))) (cons (hd (tl V2767)) (shen.find-types (tl (tl V2767))))) ((cons? V2767) (append (shen.find-types (hd V2767)) (shen.find-types (tl V2767)))) (true ())))

(defun shen.find-arities (V2770) (cond ((and (cons? V2770) (and (= define (hd V2770)) (and (cons? (tl V2770)) (and (cons? (tl (tl V2770))) (= { (hd (tl (tl V2770)))))))) (shen.store-arity (hd (tl V2770)) (shen.find-arity (hd (tl V2770)) 1 (tl (tl (tl V2770)))))) ((and (cons? V2770) (and (= define (hd V2770)) (cons? (tl V2770)))) (shen.store-arity (hd (tl V2770)) (shen.find-arity (hd (tl V2770)) 0 (tl (tl V2770))))) ((cons? V2770) (map (lambda Z (shen.find-arities Z)) V2770)) (true shen.skip)))

(defun shen.store-arity (V2771 V2772) (let ArityF (arity V2771) (if (= ArityF -1) (shen.execute-store-arity V2771 V2772) (if (= ArityF V2772) shen.skip (do (pr (cn "changing the arity of " (shen.app V2771 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V2771 V2772))))))

(defun shen.execute-store-arity (V2773 V2774) (cond ((= 0 V2774) (put V2773 arity 0 (value *property-vector*))) (true (do (put V2773 arity V2774 (value *property-vector*)) (shen.update-lambdatable V2773 V2774)))))

(defun shen.update-lambdatable (V2775 V2776) (let LambdaTable (value shen.*lambdatable*) (let Lambda (eval-kl (shen.lambda-function (cons V2775 ()) V2776)) (let Insert (shen.assoc-> V2775 Lambda LambdaTable) (let Reset (set shen.*lambdatable* Insert) Reset)))))

(defun shen.lambda-function (V2779 V2780) (cond ((= 0 V2780) shen.skip) ((= 1 V2780) (let X (protect (gensym Y)) (cons lambda (cons X (cons (append V2779 (cons X ())) ()))))) (true (let X (protect (gensym Y)) (cons lambda (cons X (cons (shen.lambda-function (append V2779 (cons X ())) (- V2780 1)) ())))))))

(defun shen.assoc-> (V2790 V2791 V2792) (cond ((= () V2792) (cons (cons V2790 V2791) ())) ((and (cons? V2792) (and (cons? (hd V2792)) (= V2790 (hd (hd V2792))))) (cons (cons (hd (hd V2792)) V2791) (tl V2792))) ((cons? V2792) (cons (hd V2792) (shen.assoc-> V2790 V2791 (tl V2792)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V2807 V2808 V2809) (cond ((and (= 0 V2808) (and (cons? V2809) (= (hd V2809) ->))) 0) ((and (= 0 V2808) (and (cons? V2809) (= (hd V2809) <-))) 0) ((and (= 0 V2808) (cons? V2809)) (+ 1 (shen.find-arity V2807 0 (tl V2809)))) ((and (= 1 V2808) (and (cons? V2809) (= } (hd V2809)))) (shen.find-arity V2807 0 (tl V2809))) ((and (= 1 V2808) (cons? V2809)) (shen.find-arity V2807 1 (tl V2809))) ((= 1 V2808) (simple-error (cn "syntax error in " (shen.app V2807 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V2807 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V2810) (let Result (let Parseshen.<lsb> (shen.<lsb> V2810) (if (shen.parse-failure? Parseshen.<lsb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lsb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rsb> (shen.<rsb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rsb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rsb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (cons (shen.cons-form (shen.<-out Parseshen.<s-exprs1>)) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lrb> (shen.<lrb> V2810) (if (shen.parse-failure? Parseshen.<lrb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lrb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rrb> (shen.<rrb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rrb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rrb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (shen.add-sexpr (shen.<-out Parseshen.<s-exprs1>) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lcurly> (shen.<lcurly> V2810) (if (shen.parse-failure? Parseshen.<lcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<lcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons { (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rcurly> (shen.<rcurly> V2810) (if (shen.parse-failure? Parseshen.<rcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<rcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons } (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<bar> (shen.<bar> V2810) (if (shen.parse-failure? Parseshen.<bar>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<bar>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons bar! (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<semicolon> (shen.<semicolon> V2810) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<semicolon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ";") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V2810) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<equal> (shen.<equal> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<equal>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<equal>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":=") (shen.<-out Parseshen.<s-exprs>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V2810) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comma> (shen.<comma> V2810) (if (shen.parse-failure? Parseshen.<comma>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comma>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ",") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comment> (shen.<comment> V2810) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<atom> (shen.<atom> V2810) (if (shen.parse-failure? Parseshen.<atom>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<atom>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (shen.<-out Parseshen.<atom>) (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespaces> (shen.<whitespaces> V2810) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<whitespaces>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2810) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.add-sexpr (V2811 V2812) (cond ((and (cons? V2811) (and (= $ (hd V2811)) (and (cons? (tl V2811)) (= () (tl (tl V2811)))))) (append (explode (hd (tl V2811))) V2812)) (true (cons V2811 V2812))))

(defun shen.<lsb> (V2813) (let Result (if (shen.=hd? V2813 91) (let News2495 (shen.tls V2813) (shen.comb (shen.in-> News2495) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rsb> (V2814) (let Result (if (shen.=hd? V2814 93) (let News2497 (shen.tls V2814) (shen.comb (shen.in-> News2497) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs1> (V2815) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V2815) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs2> (V2816) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V2816) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.cons-form (V2818) (cond ((= () V2818) ()) ((and (cons? V2818) (and (cons? (tl V2818)) (and (cons? (tl (tl V2818))) (and (= () (tl (tl (tl V2818)))) (= (hd (tl V2818)) bar!))))) (cons cons (cons (hd V2818) (tl (tl V2818))))) ((and (cons? V2818) (and (cons? (tl V2818)) (and (cons? (tl (tl V2818))) (and (cons? (tl (tl (tl V2818)))) (= (hd (tl V2818)) bar!))))) (simple-error "misapplication of |
")) ((cons? V2818) (cons cons (cons (hd V2818) (cons (shen.cons-form (tl V2818)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V2819) (let Result (if (shen.=hd? V2819 40) (let News2501 (shen.tls V2819) (shen.comb (shen.in-> News2501) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rrb> (V2820) (let Result (if (shen.=hd? V2820 41) (let News2503 (shen.tls V2820) (shen.comb (shen.in-> News2503) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lcurly> (V2821) (let Result (if (shen.=hd? V2821 123) (let News2505 (shen.tls V2821) (shen.comb (shen.in-> News2505) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rcurly> (V2822) (let Result (if (shen.=hd? V2822 125) (let News2507 (shen.tls V2822) (shen.comb (shen.in-> News2507) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<bar> (V2823) (let Result (if (shen.=hd? V2823 124) (let News2509 (shen.tls V2823) (shen.comb (shen.in-> News2509) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<semicolon> (V2824) (let Result (if (shen.=hd? V2824 59) (let News2511 (shen.tls V2824) (shen.comb (shen.in-> News2511) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<colon> (V2825) (let Result (if (shen.=hd? V2825 58) (let News2513 (shen.tls V2825) (shen.comb (shen.in-> News2513) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comma> (V2826) (let Result (if (shen.=hd? V2826 44) (let News2515 (shen.tls V2826) (shen.comb (shen.in-> News2515) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<equal> (V2827) (let Result (if (shen.=hd? V2827 61) (let News2517 (shen.tls V2827) (shen.comb (shen.in-> News2517) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comment> (V2828) (let Result (let Parseshen.<singleline> (shen.<singleline> V2828) (if (shen.parse-failure? Parseshen.<singleline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<singleline>) shen.skip))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<multiline> (shen.<multiline> V2828) (if (shen.parse-failure? Parseshen.<multiline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<multiline>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<singleline> (V2829) (let Result (let Parseshen.<backslash> (shen.<backslash> V2829) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<shortnatters>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<backslash> (V2830) (let Result (if (shen.=hd? V2830 92) (let News2521 (shen.tls V2830) (shen.comb (shen.in-> News2521) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<shortnatters> (V2831) (let Result (let Parseshen.<shortnatter> (shen.<shortnatter> V2831) (if (shen.parse-failure? Parseshen.<shortnatter>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<shortnatter>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<shortnatters>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2831) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<shortnatter> (V2832) (let Result (if (shen.non-empty-stream? V2832) (let Byte (shen.hds V2832) (let News2524 (shen.tls V2832) (if (not (shen.return? Byte)) (shen.comb (shen.in-> News2524) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<returns> (V2833) (let Result (let Parseshen.<return> (shen.<return> V2833) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<return>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<return> (shen.<return> V2833) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<return>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<return> (V2834) (let Result (if (shen.non-empty-stream? V2834) (let Byte (shen.hds V2834) (let News2527 (shen.tls V2834) (if (shen.return? Byte) (shen.comb (shen.in-> News2527) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.return? (V2835) (element? V2835 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V2836) (let Result (let Parseshen.<backslash> (shen.<backslash> V2836) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<times> (shen.<times> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<times> (V2837) (let Result (if (shen.=hd? V2837 42) (let News2530 (shen.tls V2837) (shen.comb (shen.in-> News2530) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<longnatter> (V2838) (let Result (let Parseshen.<comment> (shen.<comment> V2838) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<times> (shen.<times> V2838) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<backslash>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V2838) (let News2532 (shen.tls V2838) (let Parseshen.<longnatter> (shen.<longnatter> News2532) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<atom> (V2839) (let Result (let Parseshen.<str> (shen.<str> V2839) (if (shen.parse-failure? Parseshen.<str>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<str>) (shen.<-out Parseshen.<str>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<number> (shen.<number> V2839) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<sym> (shen.<sym> V2839) (if (shen.parse-failure? Parseshen.<sym>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sym>) (if (= (shen.<-out Parseshen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.<-out Parseshen.<sym>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<sym> (V2840) (let Result (let Parseshen.<alpha> (shen.<alpha> V2840) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alpha>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alpha>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<alpha> (V2841) (let Result (if (shen.non-empty-stream? V2841) (let Byte (shen.hds V2841) (let News2536 (shen.tls V2841) (if (shen.alpha? Byte) (shen.comb (shen.in-> News2536) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.alpha? (V2842) (or (shen.lowercase? V2842) (or (shen.uppercase? V2842) (shen.misc? V2842))))

(defun shen.lowercase? (V2843) (and (>= V2843 97) (<= V2843 122)))

(defun shen.uppercase? (V2844) (and (>= V2844 65) (<= V2844 90)))

(defun shen.misc? (V2845) (element? V2845 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V2846) (let Result (let Parseshen.<alphanum> (shen.<alphanum> V2846) (if (shen.parse-failure? Parseshen.<alphanum>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alphanum>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alphanum>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2846) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<alphanum> (V2847) (let Result (let Parseshen.<alpha> (shen.<alpha> V2847) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alpha>) (shen.<-out Parseshen.<alpha>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<numeral> (shen.<numeral> V2847) (if (shen.parse-failure? Parseshen.<numeral>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<numeral>) (shen.<-out Parseshen.<numeral>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<numeral> (V2848) (let Result (if (shen.non-empty-stream? V2848) (let Byte (shen.hds V2848) (let News2540 (shen.tls V2848) (if (shen.digit? Byte) (shen.comb (shen.in-> News2540) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.digit? (V2849) (and (>= V2849 48) (<= V2849 57)))

(defun shen.<str> (V2850) (let Result (let Parseshen.<dbq> (shen.<dbq> V2850) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<dbq>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (let Parseshen.<dbq> (shen.<dbq> Parseshen.<strcontents>) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<dbq>) (shen.<-out Parseshen.<strcontents>)))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbq> (V2851) (let Result (if (shen.=hd? V2851 34) (let News2543 (shen.tls V2851) (shen.comb (shen.in-> News2543) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<strcontents> (V2852) (let Result (let Parseshen.<strc> (shen.<strc> V2852) (if (shen.parse-failure? Parseshen.<strc>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<strc>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<strcontents>) (cn (shen.<-out Parseshen.<strc>) (shen.<-out Parseshen.<strcontents>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V2852) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<strc> (V2853) (let Result (let Parseshen.<control> (shen.<control> V2853) (if (shen.parse-failure? Parseshen.<control>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<control>) (shen.<-out Parseshen.<control>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<notdbq> (shen.<notdbq> V2853) (if (shen.parse-failure? Parseshen.<notdbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<notdbq>) (shen.<-out Parseshen.<notdbq>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<control> (V2854) (let Result (let Parseshen.<lowC> (shen.<lowC> V2854) (if (shen.parse-failure? Parseshen.<lowC>) (shen.parse-failure) (let Parseshen.<hash> (shen.<hash> Parseshen.<lowC>) (if (shen.parse-failure? Parseshen.<hash>) (shen.parse-failure) (let Parseshen.<integer> (shen.<integer> Parseshen.<hash>) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<semicolon> (shen.<semicolon> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<semicolon>) (n->string (shen.<-out Parseshen.<integer>))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<notdbq> (V2855) (let Result (if (shen.non-empty-stream? V2855) (let Byte (shen.hds V2855) (let News2548 (shen.tls V2855) (if (not (= Byte 34)) (shen.comb (shen.in-> News2548) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lowC> (V2856) (let Result (if (shen.=hd? V2856 99) (let News2550 (shen.tls V2856) (shen.comb (shen.in-> News2550) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<hash> (V2857) (let Result (if (shen.=hd? V2857 35) (let News2552 (shen.tls V2857) (shen.comb (shen.in-> News2552) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<number> (V2858) (let Result (let Parseshen.<minus> (shen.<minus> V2858) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (- 0 (shen.<-out Parseshen.<number>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<plus> (shen.<plus> V2858) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<e-number> (shen.<e-number> V2858) (if (shen.parse-failure? Parseshen.<e-number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<e-number>) (shen.<-out Parseshen.<e-number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<float> (shen.<float> V2858) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<float>) (shen.<-out Parseshen.<float>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V2858) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)))

(defun shen.<minus> (V2859) (let Result (if (shen.=hd? V2859 45) (let News2555 (shen.tls V2859) (shen.comb (shen.in-> News2555) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<plus> (V2860) (let Result (if (shen.=hd? V2860 43) (let News2557 (shen.tls V2860) (shen.comb (shen.in-> News2557) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<integer> (V2861) (let Result (let Parseshen.<digits> (shen.<digits> V2861) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-integer (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<digits> (V2862) (let Result (let Parseshen.<digit> (shen.<digit> V2862) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (let Parseshen.<digits> (shen.<digits> Parseshen.<digit>) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (cons (shen.<-out Parseshen.<digit>) (shen.<-out Parseshen.<digits>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<digit> (shen.<digit> V2862) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digit>) (cons (shen.<-out Parseshen.<digit>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<digit> (V2863) (let Result (if (shen.non-empty-stream? V2863) (let Byte (shen.hds V2863) (let News2561 (shen.tls V2863) (if (shen.digit? Byte) (shen.comb (shen.in-> News2561) (shen.byte->digit Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.byte->digit (V2864) (- V2864 48))

(defun shen.compute-integer (V2865) (shen.compute-integer-h (reverse V2865) 0))

(defun shen.compute-integer-h (V2868 V2869) (cond ((= () V2868) 0) ((cons? V2868) (+ (* (shen.expt 10 V2869) (hd V2868)) (shen.compute-integer-h (tl V2868) (+ V2869 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V2872 V2873) (cond ((= 0 V2873) 1) ((> V2873 0) (* V2872 (shen.expt V2872 (- V2873 1)))) (true (/ (shen.expt V2872 (+ V2873 1)) V2872))))

(defun shen.<float> (V2874) (let Result (let Parseshen.<integer> (shen.<integer> V2874) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<stop> (shen.<stop> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (+ (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<fraction>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<stop> (shen.<stop> V2874) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (shen.<-out Parseshen.<fraction>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<stop> (V2875) (let Result (if (shen.=hd? V2875 46) (let News2564 (shen.tls V2875) (shen.comb (shen.in-> News2564) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<fraction> (V2876) (let Result (let Parseshen.<digits> (shen.<digits> V2876) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-fraction (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-fraction (V2877) (shen.compute-fraction-h V2877 -1))

(defun shen.compute-fraction-h (V2880 V2881) (cond ((= () V2880) 0) ((cons? V2880) (+ (* (shen.expt 10 V2881) (hd V2880)) (shen.compute-fraction-h (tl V2880) (- V2881 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V2882) (let Result (let Parseshen.<float> (shen.<float> V2882) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<float>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<float>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V2882) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<log10> (V2883) (let Result (let Parseshen.<plus> (shen.<plus> V2883) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.<-out Parseshen.<log10>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<minus> (shen.<minus> V2883) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (- 0 (shen.<-out Parseshen.<log10>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V2883) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<lowE> (V2884) (let Result (if (shen.=hd? V2884 101) (let News2569 (shen.tls V2884) (shen.comb (shen.in-> News2569) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-E (V2885 V2886) (* V2885 (shen.expt 10 V2886)))

(defun shen.<whitespaces> (V2887) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V2887) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (let Parseshen.<whitespaces> (shen.<whitespaces> Parseshen.<whitespace>) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespaces>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V2887) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespace>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<whitespace> (V2888) (let Result (if (shen.non-empty-stream? V2888) (let Byte (shen.hds V2888) (let News2572 (shen.tls V2888) (if (shen.whitespace? Byte) (shen.comb (shen.in-> News2572) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.whitespace? (V2891) (cond ((= 32 V2891) true) ((= 13 V2891) true) ((= 10 V2891) true) ((= 9 V2891) true) (true false)))

(defun shen.unpackage&macroexpand (V2892) (cond ((= () V2892) ()) ((and (cons? V2892) (shen.packaged? (hd V2892))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V2892)) (tl V2892)))) ((cons? V2892) (let M (macroexpand (hd V2892)) (if (shen.packaged? M) (shen.unpackage&macroexpand (cons M (tl V2892))) (cons M (shen.unpackage&macroexpand (tl V2892)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V2895) (cond ((and (cons? V2895) (and (= package (hd V2895)) (and (cons? (tl V2895)) (cons? (tl (tl V2895)))))) true) (true false)))

(defun shen.unpackage (V2898) (cond ((and (cons? V2898) (and (= package (hd V2898)) (and (cons? (tl V2898)) (and (= null (hd (tl V2898))) (cons? (tl (tl V2898))))))) (tl (tl (tl V2898)))) ((and (cons? V2898) (and (= package (hd V2898)) (and (cons? (tl V2898)) (cons? (tl (tl V2898)))))) (let External! (eval (hd (tl (tl V2898)))) (let Package (shen.package-symbols (str (hd (tl V2898))) External! (tl (tl (tl V2898)))) (let RecordExternal (shen.record-external (hd (tl V2898)) External!) Package)))) (true (shen.f-error shen.unpackage))))

(defun shen.record-external (V2899 V2900) (let External (trap-error (get V2899 shen.external-symbols (value *property-vector*)) (lambda E ())) (put V2899 shen.external-symbols (union V2900 External) (value *property-vector*))))

(defun shen.package-symbols (V2905 V2906 V2907) (cond ((cons? V2907) (map (lambda X (shen.package-symbols V2905 V2906 X)) V2907)) ((shen.internal? V2907 V2905 V2906) (shen.intern-in-package V2905 V2907)) (true V2907)))

(defun shen.intern-in-package (V2908 V2909) (intern (@s V2908 (@s "." (str V2909)))))

(defun shen.internal? (V2910 V2911 V2912) (and (not (element? V2910 V2912)) (and (not (shen.sng? V2910)) (and (not (shen.dbl? V2910)) (and (symbol? V2910) (and (not (shen.sysfunc? V2910)) (and (not (variable? V2910)) (and (not (shen.internal-to-shen? (str V2910))) (not (shen.internal-to-P? V2911 (str V2910)))))))))))

(defun shen.internal-to-shen? (V2917) (cond ((and (shen.+string? V2917) (and (= "s" (hdstr V2917)) (and (shen.+string? (tlstr V2917)) (and (= "h" (hdstr (tlstr V2917))) (and (shen.+string? (tlstr (tlstr V2917))) (and (= "e" (hdstr (tlstr (tlstr V2917)))) (and (shen.+string? (tlstr (tlstr (tlstr V2917)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V2917))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V2917))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V2917))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V2918) (element? V2918 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V2926 V2927) (cond ((and (= "" V2926) (and (shen.+string? V2927) (= "." (hdstr V2927)))) true) ((and (shen.+string? V2926) (and (shen.+string? V2927) (= (hdstr V2926) (hdstr V2927)))) (shen.internal-to-P? (tlstr V2926) (tlstr V2927))) (true false)))

(defun shen.process-applications (V2930 V2931) (cond ((element? V2930 V2931) V2930) ((and (cons? V2930) (shen.non-application? (hd V2930))) (shen.special-case (hd V2930) V2930 V2931)) ((cons? V2930) (shen.process-application (map (lambda Y (shen.process-applications Y V2931)) V2930) V2931)) (true V2930)))

(defun shen.non-application? (V2934) (cond ((= define V2934) true) ((= defun V2934) true) ((= synonyms V2934) true) ((shen.special? V2934) true) ((shen.extraspecial? V2934) true) (true false)))

(defun shen.special-case (V2939 V2940 V2941) (cond ((and (= lambda V2939) (and (cons? V2940) (and (= lambda (hd V2940)) (and (cons? (tl V2940)) (and (cons? (tl (tl V2940))) (= () (tl (tl (tl V2940))))))))) (cons lambda (cons (hd (tl V2940)) (cons (shen.process-applications (hd (tl (tl V2940))) V2941) ())))) ((and (= let V2939) (and (cons? V2940) (and (= let (hd V2940)) (and (cons? (tl V2940)) (and (cons? (tl (tl V2940))) (and (cons? (tl (tl (tl V2940)))) (= () (tl (tl (tl (tl V2940))))))))))) (cons let (cons (hd (tl V2940)) (cons (shen.process-applications (hd (tl (tl V2940))) V2941) (cons (shen.process-applications (hd (tl (tl (tl V2940)))) V2941) ()))))) ((and (= defun V2939) (and (cons? V2940) (and (= defun (hd V2940)) (and (cons? (tl V2940)) (and (cons? (tl (tl V2940))) (and (cons? (tl (tl (tl V2940)))) (= () (tl (tl (tl (tl V2940))))))))))) V2940) ((and (= define V2939) (and (cons? V2940) (and (= define (hd V2940)) (and (cons? (tl V2940)) (and (cons? (tl (tl V2940))) (= { (hd (tl (tl V2940))))))))) (cons define (cons (hd (tl V2940)) (cons { (shen.process-after-type (hd (tl V2940)) (tl (tl (tl V2940))) V2941))))) ((and (= define V2939) (and (cons? V2940) (and (= define (hd V2940)) (cons? (tl V2940))))) (cons define (cons (hd (tl V2940)) (map (lambda Y (shen.process-applications Y V2941)) (tl (tl V2940)))))) ((= synonyms V2939) (cons synonyms V2940)) ((and (= type V2939) (and (cons? V2940) (and (= type (hd V2940)) (and (cons? (tl V2940)) (and (cons? (tl (tl V2940))) (= () (tl (tl (tl V2940))))))))) (cons type (cons (shen.process-applications (hd (tl V2940)) V2941) (tl (tl V2940))))) ((and (= input+ V2939) (and (cons? V2940) (and (= input+ (hd V2940)) (and (cons? (tl V2940)) (and (cons? (tl (tl V2940))) (= () (tl (tl (tl V2940))))))))) (cons input+ (cons (hd (tl V2940)) (cons (shen.process-applications (hd (tl (tl V2940))) V2941) ())))) ((and (cons? V2940) (shen.special? (hd V2940))) (cons (hd V2940) (map (lambda Y (shen.process-applications Y V2941)) (tl V2940)))) ((and (cons? V2940) (shen.extraspecial? (hd V2940))) V2940) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V2944 V2945 V2946) (cond ((and (cons? V2945) (= } (hd V2945))) (cons } (map (lambda Y (shen.process-applications Y V2946)) (tl V2945)))) ((cons? V2945) (cons (hd V2945) (shen.process-after-type V2944 (tl V2945) V2946))) (true (simple-error (cn "missing } in " (shen.app V2944 "
" shen.a))))))

(defun shen.process-application (V2947 V2948) (cond ((cons? V2947) (let ArityF (arity (hd V2947)) (let N (length (tl V2947)) (if (element? V2947 V2948) V2947 (if (shen.shen-call? (hd V2947)) V2947 (if (shen.fn-call? V2947) (shen.fn-call V2947) (if (shen.zero-place? V2947) V2947 (if (shen.undefined-f? (hd V2947) ArityF) (shen.simple-curry (cons (cons fn (cons (hd V2947) ())) (tl V2947))) (if (variable? (hd V2947)) (shen.simple-curry V2947) (if (shen.application? (hd V2947)) (shen.simple-curry V2947) (if (shen.partial-application*? (hd V2947) ArityF N) (shen.lambda-function V2947 (- ArityF N)) (if (shen.overapplication? (hd V2947) ArityF N) (shen.simple-curry V2947) V2947)))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.zero-place? (V2951) (cond ((and (cons? V2951) (= () (tl V2951))) true) (true false)))

(defun shen.shen-call? (V2952) (and (symbol? V2952) (shen.internal-to-shen? (str V2952))))

(defun shen.internal-to-shen? (V2957) (cond ((and (shen.+string? V2957) (and (= "s" (hdstr V2957)) (and (shen.+string? (tlstr V2957)) (and (= "h" (hdstr (tlstr V2957))) (and (shen.+string? (tlstr (tlstr V2957))) (and (= "e" (hdstr (tlstr (tlstr V2957)))) (and (shen.+string? (tlstr (tlstr (tlstr V2957)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V2957))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V2957))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V2957))))))))))))))) true) (true false)))

(defun shen.application? (V2958) (cons? V2958))

(defun shen.undefined-f? (V2963 V2964) (cond ((= -1 V2964) (and (shen.lowercase-symbol? V2963) (not (element? V2963 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V2965) (and (symbol? V2965) (not (variable? V2965))))

(defun shen.simple-curry (V2966) (cond ((and (cons? V2966) (and (cons? (tl V2966)) (= () (tl (tl V2966))))) V2966) ((and (cons? V2966) (and (cons? (tl V2966)) (cons? (tl (tl V2966))))) (shen.simple-curry (cons (cons (hd V2966) (cons (hd (tl V2966)) ())) (tl (tl V2966))))) (true V2966)))

(defun function (V2967) (fn V2967))

(defun fn (V2968) (let LookUp (assoc V2968 (value shen.*lambdatable*)) (if (empty? LookUp) (simple-error (cn "fn: " (shen.app V2968 " is undefined
" shen.a))) (tl LookUp))))

(defun shen.fn-call? (V2971) (cond ((and (cons? V2971) (and (= fn (hd V2971)) (and (cons? (tl V2971)) (= () (tl (tl V2971)))))) true) ((and (cons? V2971) (and (= function (hd V2971)) (and (cons? (tl V2971)) (= () (tl (tl V2971)))))) true) (true false)))

(defun shen.fn-call (V2972) (cond ((and (cons? V2972) (and (= function (hd V2972)) (and (cons? (tl V2972)) (= () (tl (tl V2972)))))) (shen.fn-call (cons fn (tl V2972)))) ((and (cons? V2972) (and (= fn (hd V2972)) (and (cons? (tl V2972)) (= () (tl (tl V2972)))))) (let ArityF (arity (hd (tl V2972))) (if (= ArityF -1) V2972 (if (= ArityF 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V2972) ArityF))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V2973 V2974 V2975) (let Verdict (> V2974 V2975) (let Message (if (and Verdict (and (shen.loading?) (not (element? V2973 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V2973 "
" shen.a)) (stoutput)) shen.skip) Verdict)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V2976 V2977 V2978) (let Verdict (< V2977 V2978) (let Message (if (and Verdict (shen.loading?)) (pr (shen.app V2976 (cn " might not like " (shen.app V2978 (cn " argument" (shen.app (if (= V2978 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) Verdict)))

